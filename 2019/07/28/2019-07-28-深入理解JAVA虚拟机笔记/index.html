<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="google-site-verification" content="hnyb1jnM5Q6co65Dc7FMFxsxfL0wQ_aH1"><meta name="msvalidate.01" content="F2FFFBA1A6155C91A31EAC77F525BBD5"><meta name="baidu-site-verification" content="code-v7NaUITwkJ"><meta name="360-site-verification" content="cd75d354b11109d6f9f4ed94aff26cd6"><meta name="description" content="阅读了《深入理解Java虚拟机》的部分章节，并做了一些简单的笔记，不是很详细，但是可以方便自己查阅。"><meta property="og:type" content="article"><meta property="og:title" content="《深入理解Java虚拟机》笔记"><meta property="og:url" content="http://fxbing.github.io/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="小兵的博客"><meta property="og:description" content="阅读了《深入理解Java虚拟机》的部分章节，并做了一些简单的笔记，不是很详细，但是可以方便自己查阅。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.bmp.ovh/imgs/2019/05/8e139eb7578dd5fc.jpg"><meta property="og:image" content="https://i.bmp.ovh/imgs/2019/05/ab251c96094d3f7d.png"><meta property="og:image" content="https://images2018.cnblogs.com/blog/1256203/201807/1256203-20180714171531925-1737231049.png"><meta property="og:image" content="https://img-blog.csdn.net/20180522220730109"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-326a2be9b86b1446d75b6f52f54c98fb_hd.jpg"><meta property="article:published_time" content="2019-07-27T16:00:00.000Z"><meta property="article:modified_time" content="2019-07-27T16:00:00.000Z"><meta property="article:author" content="fxbing"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.bmp.ovh/imgs/2019/05/8e139eb7578dd5fc.jpg"><title>《深入理解Java虚拟机》笔记 | 小兵的博客</title><link ref="canonical" href="http://fxbing.github.io/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="dns-prefetch" href="https://hm.baidu.com"><script src="https://www.googletagmanager.com/gtag/js?id=139855287" async></script><script>function gtag(){dataLayer.push(arguments)}"localhost"!==window.location.hostname&&(window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","139855287"))</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e195e7c765ecde120b81d5afafa26e4b",e.async=!0;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:void 0,fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"20px",tocMaxDepth:6},header:void 0,postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},codeblock:{style:"carbon",highlight:"ocean",wordWrap:!1},reward:!1,fancybox:!1,zoomImage:{gapAside:"20px"},galleryWaterfall:void 0,lazyload:!1,pjax:void 0,externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"复制成功",copyError:"复制失败"},sourcePath:{js:"js",css:"css",images:"images"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">《深入理解Java虚拟机》笔记</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-07-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2019-07-28</span></span></div></header><div class="post-body"><p>阅读了《深入理解Java虚拟机》的部分章节，并做了一些简单的笔记，不是很详细，但是可以方便自己查阅。</p><span id="more"></span><h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h3 id="1-对象是否存活"><a href="#1-对象是否存活" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-对象是否存活" class="headerlink" title="1. 对象是否存活"></a>1. 对象是否存活</h3><h4 id="引用计数法："><a href="#引用计数法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数法：" class="headerlink" title="引用计数法："></a>引用计数法：</h4><p>很难解决对象间的循环引用</p><h4 id="可达性分析"><a href="#可达性分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><h5 id="可以作为GC-Roots的对象："><a href="#可以作为GC-Roots的对象：" class="heading-link"><i class="fas fa-link"></i></a><a href="#可以作为GC-Roots的对象：" class="headerlink" title="可以作为GC Roots的对象："></a>可以作为GC Roots的对象：</h5><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><h3 id="2-引用分类（JDK1-2实现）"><a href="#2-引用分类（JDK1-2实现）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-引用分类（JDK1-2实现）" class="headerlink" title="2. 引用分类（JDK1.2实现）"></a>2. 引用分类（JDK1.2实现）</h3><ul><li><strong>强引用</strong>：永远不回收</li><li><strong>软引用SoftReference</strong>（有用但非必须）：内存溢出之前回收</li><li><strong>弱引用WeakReference</strong>（非必须）：GC时回收</li><li><strong>虚引用PhantomReference</strong>（幽灵引用/幻影引用）：目的是能在这个对象被收集器回收时收到一个系统通知</li></ul><h3 id="3-finalize-（不建议使用）"><a href="#3-finalize-（不建议使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-finalize-（不建议使用）" class="headerlink" title="3. finalize()（不建议使用）"></a>3. finalize()（不建议使用）</h3><blockquote><p>判断对象是否死亡会经历<strong>两次标记</strong>过程：<br>①判断是否与GC Roots相连；<br>②执行finalize()（对象没有覆盖finalize()或finalize()已经被调用过一次时，虚拟机认为没必要执行finalize()，不会进行第二次标记）。</p></blockquote><ul><li>被调用时会放在由虚拟机自动创建的、低优先级的队列<strong>F-Queue</strong>中</li><li>finalize()是对象唯一的自救机会，例如：在finalize()中将this赋值给某个类变量或者对象的成员变量</li><li>运行代价高昂，不确定性大、无法保证各个对象的调用顺序</li><li>finalize()能做的所有工作使用try-finally或者其他方式可以做得更好、更及时</li></ul><h3 id="4-回收方法区"><a href="#4-回收方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-回收方法区" class="headerlink" title="4. 回收方法区"></a>4. 回收方法区</h3><h5 id="废弃常量"><a href="#废弃常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h5><p>与Java堆的回收逻辑类似</p><h5 id="无用的类"><a href="#无用的类" class="heading-link"><i class="fas fa-link"></i></a><a href="#无用的类" class="headerlink" title="无用的类"></a>无用的类</h5><ul><li>该类的所有实例已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-垃圾收集算法" class="headerlink" title="5. 垃圾收集算法"></a>5. 垃圾收集算法</h3><h4 id="（1）标记清除算法"><a href="#（1）标记清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）标记清除算法" class="headerlink" title="（1）标记清除算法"></a>（1）标记清除算法</h4><ul><li>效率不高</li><li>会大量不连续内存碎片</li></ul><h4 id="（2）复制算法"><a href="#（2）复制算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）复制算法" class="headerlink" title="（2）复制算法"></a>（2）复制算法</h4><ul><li>内存缩小为原来的一半</li><li>HotSpot默认的Eden与Survivor的大小比例为8:1</li><li>没有办法保证每次回收都只有不多于10%的对象存活。当Survivor空间不够用时，需要依赖老年代进行<strong>分配担保</strong>。<blockquote><p>分配担保：当Survivor空间不能放下上一次 YGC 之后存活的对象时，这些对象直接通过分配担保机制进入老年代。</p></blockquote></li></ul><h4 id="（3）标记整理算法"><a href="#（3）标记整理算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）标记整理算法" class="headerlink" title="（3）标记整理算法"></a>（3）标记整理算法</h4><h4 id="（4）分代收集算法"><a href="#（4）分代收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）分代收集算法" class="headerlink" title="（4）分代收集算法"></a>（4）分代收集算法</h4><p>新生代每次垃圾收集都会有大量对象死去，少量存活，所以采用复制算法。<br>老年代对象存活率高、没有额外的空间对它进行担保，必须使用“标记-清理”或者“标记-整理”算法。</p><h3 id="6-HotSpot算法实现"><a href="#6-HotSpot算法实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-HotSpot算法实现" class="headerlink" title="6. HotSpot算法实现"></a>6. HotSpot算法实现</h3><h4 id="（1）枚举根节点"><a href="#（1）枚举根节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）枚举根节点" class="headerlink" title="（1）枚举根节点"></a>（1）枚举根节点</h4><ul><li>Java虚拟机使用准确式GC（必须确定一个变量是引用还是真正的数据）</li><li>虚拟机停顿之后不需要检查所有的执行上下文和全局的引用位置。</li><li>类加载完成时计算出什么偏移量上是什么类型的数据，JIT编译时在特定位置（<strong>安全点</strong>）记录<strong>OopMap</strong>数据结构（指明栈和寄存器哪些位置是引用）</li></ul><h4 id="（2）安全点（SafePoint）"><a href="#（2）安全点（SafePoint）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）安全点（SafePoint）" class="headerlink" title="（2）安全点（SafePoint）"></a>（2）安全点（SafePoint）</h4><ul><li>程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停。</li><li><strong>安全点选定原则</strong>：是否具有让程序<strong>长时间执行</strong>的特征</li><li><strong>长时间执行</strong>：指令序列复用（如：方法调用、循环跳转、异常跳转）</li><li><strong>抢先式中断（已经被弃用）</strong>：所有线程中断，不在安全点的线程恢复执行。</li></ul><p><strong>主动式中断</strong>：在安全点设置中断标志，程序执行到安全点时主动轮询这个标志，判断是否需要进行中断。</p><h4 id="（3）安全区域（Safe-Region）"><a href="#（3）安全区域（Safe-Region）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）安全区域（Safe-Region）" class="headerlink" title="（3）安全区域（Safe Region）"></a>（3）安全区域（Safe Region）</h4><ul><li>定义：一段代码中，引用关系不会发生变化。（线程处于Sleep或Blocked状态）</li><li>线程执行到Safe Region时，标识自己进入Safe Region状态；<br>JVM GC时不管Safe Region状态的线程；<br>当线程离开Safe Region状态时，检查系统是否完成了根节点枚举或整个GC过程；<br>如果完成了，那线程继续执行，否则，必须等待收到可以安全离开Safe Region的信号为止。</li></ul><h3 id="7-垃圾收集器"><a href="#7-垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-垃圾收集器" class="headerlink" title="7. 垃圾收集器"></a>7. 垃圾收集器</h3><p>连线代表可以组合使用。<br><img src="https://i.bmp.ovh/imgs/2019/05/8e139eb7578dd5fc.jpg"></p><h4 id="（1）Serial收集器（Client模式下新生代垃圾清理首选）"><a href="#（1）Serial收集器（Client模式下新生代垃圾清理首选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）Serial收集器（Client模式下新生代垃圾清理首选）" class="headerlink" title="（1）Serial收集器（Client模式下新生代垃圾清理首选）"></a>（1）Serial收集器（Client模式下新生代垃圾清理首选）</h4><ul><li>进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</li><li>Serial/Serial Old收集器在新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</li></ul><h4 id="（2）ParNew收集器（Server模式下新生代垃圾清理首选）"><a href="#（2）ParNew收集器（Server模式下新生代垃圾清理首选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）ParNew收集器（Server模式下新生代垃圾清理首选）" class="headerlink" title="（2）ParNew收集器（Server模式下新生代垃圾清理首选）"></a>（2）ParNew收集器（Server模式下新生代垃圾清理首选）</h4><ul><li>多线程版本的Serial收集器</li><li>第一款真正意义上的<strong>并发</strong>收集器</li><li>默认开启的收集线程数与CPU的数量相同</li></ul><h4 id="（3）Parallel-Scavenge收集器"><a href="#（3）Parallel-Scavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h4><ul><li>目标：达到一个可控制的吞吐量。（吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)）</li><li>适合在后台运算而不需要太多交互的任务</li><li>可以设置最大垃圾收集停段时间（-XX:MaxGCPauseMillis）和吞吐量大小（-XX:GCTimeRatio）</li><li>可以开启-XX:UseAdaptiveSizePolicy，之后虚拟机根据系统运行状况自动设置新生代大小、Eden与Survivor比例、晋升老年代对象大小等细节参数。（<strong>GC自适应的调节策略</strong>）</li></ul><h4 id="（4）Serial-Old收集器"><a href="#（4）Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h4><h4 id="（5）Parallel-Old收集器"><a href="#（5）Parallel-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h4><h4 id="（6）CMS收集器"><a href="#（6）CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h4><ul><li>四个步骤：<br>a: 初始标记（停顿）：记录与GC Roots直接相连的对象<br>b: 并发标记：GC Roots Tracing<br>c: 重新标记（停顿更长）：修正并发标记期间因用户程序继续运作而导致的标记产生变动的记录<br>d: 并发清除</li><li>对 CPU 资源敏感</li><li>无法处理<strong>浮动垃圾</strong>（并发清除阶段用户程序产生的新的垃圾，需要等下次GC时再进行清理），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。（不能等老年代被填满之后进行清理，需要为并发清除期间用户程序的执行预留空间）</li><li>空间碎片过多</li></ul><h4 id="（7）G1收集器（JDK1-7）"><a href="#（7）G1收集器（JDK1-7）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（7）G1收集器（JDK1-7）" class="headerlink" title="（7）G1收集器（JDK1.7）"></a>（7）G1收集器（JDK1.7）</h4><ul><li>并行与并发</li><li>分代收集</li><li><strong>空间整合</strong>：从整体上看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制“算法实现的。</li><li><strong>可预测的停顿</strong>：使用者可以指定垃圾收集上消耗的时间不得超过 M 毫秒。</li><li>分配的对象会记录在 Remembered Set 中，内存回收时再GC根节点的枚举范围中加入 Remembered Set ，确保不对全堆扫描也不会有泄露。</li><li>不计算维护 Remembered Set 的过程，可以分为以下几个步骤：<br>a: 初始标记<br>b: 并发标记<br>c: 最终标记：并发标记期间对象变化记录在线程 Remembered Set Logs 中，该阶段将 Remembered Set Logs 整合到 Remembered Set 中。<br>d: 筛选回收：根据用户期望的 GC 停顿时间制定回收计划。</li></ul><h3 id="8-内存分配与回收策略"><a href="#8-内存分配与回收策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-内存分配与回收策略" class="headerlink" title="8. 内存分配与回收策略"></a>8. 内存分配与回收策略</h3><ul><li><strong>对象优先在Eden分配</strong><blockquote><p>新生代 GC （Minor GC）：非常频繁，回收速度也比较块。<br>老年代 GC （Major GC / Full GC）：伴随至少一次的 Minor GC ， 比 Minor GC 慢10倍以上。</p></blockquote></li><li><strong>大对象直接进入老年代</strong></li><li><strong>长期存活的对象将进入老年代</strong>（可以通过 -XX:MaxTenuringThreshold 参数进行设置，默认执行完<strong>15</strong>次 Minor GC）</li><li><strong>动态对象年龄判断</strong>：如果在 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li><li><strong>空间分配担保</strong>：在进行 Minor GC 之前会执行下面的流程，<br>a: 检查<strong>老年代最大连续可用空间是否大于新生代所有对象总空间</strong>，如果是 Minor GC 可以确保安全，否则， 执行b；<br>b: 查看 HandlePromotionFailure 设置的值是否允许担保失败，如果是，执行c，否则，执行 Full GC；<br>c: 检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</strong>，如果是，尝试一次 Minor GC （可能存在风险），否则，将 HandlePromotionFailure 设置为不允许冒险，改为进行一次 Full GC。</li></ul><h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><h3 id="1-类的加载过程"><a href="#1-类的加载过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h3><p><img src="https://i.bmp.ovh/imgs/2019/05/ab251c96094d3f7d.png"></p><ul><li>按顺序按部就班的开始（不是结束，一个阶段中调用激活另一个阶段），解析阶段可以在初始化之后再开始（动态绑定）</li><li>Java虚拟机规定的必须进行<strong>初始化</strong>的5种情况：<br>（1） 遇到 new、getstatic、putstatic、invokestatic这4条字节码指令（对应使用 <strong>new 关键字实例化对象</strong>、<strong>读取或设置类的静态字段</strong>（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）以及<strong>调用一个类的静态方法</strong>几种情况）<br>（2） 反射调用。<br>（3） 初始化一个类时，如果父类没有进行过初始化，需要先触发父类初始化。<br>（4） 虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的类），虚拟机会先初始化主类。<br>（5） 但是用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例后解析结果 REF_putStatic , REF_getStatic , REF_invokeStatic 的方法句柄时，当改方法句柄对应的类没有初始化时，需要初始化该类。<blockquote><p>接口初始化时并不要求其父类接口全部都初始化完成，只有在真正使用到父类接口时才会初始化。</p></blockquote></li></ul><blockquote><h5 id="有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。"><a href="#有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。" class="heading-link"><i class="fas fa-link"></i></a><a href="#有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。" class="headerlink" title="有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。"></a>有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。</h5><p>被动引用举例：</p><ul><li>通过子类引用父类的静态字段，不会导致子类的初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化。</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul></blockquote><h4 id="1-1-加载"><a href="#1-1-加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h4><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流<blockquote><p>获取途径：ZIP包（JAR、EAR、WAR）、网络（Applet）、运行时计算生成（动态代理）、其他文件（JSP应用）、数据库</p></blockquote></li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<blockquote><ul><li>非数组类型使用引导类加载器或者用户自定义类加载器进行加载</li><li>数组的组件类型（去掉一个维度之后的类型）是引用类型，则按照普通类加载过程加载；不是引用类型，标记为与引导类加载器关联。</li><li>数组类可见性与组件类型可见性一致。如果组件类型不是引用类型，可见性默认为 public 。</li></ul></blockquote></li></ol><h4 id="1-2-验证（非常重要但不一定必要）"><a href="#1-2-验证（非常重要但不一定必要）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-验证（非常重要但不一定必要）" class="headerlink" title="1.2 验证（非常重要但不一定必要）"></a>1.2 验证（非常重要但不一定必要）</h4><ol><li>文件格式验证：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。<blockquote><p>经过此验证之后字节流才会进入内存方法区，后面3个验证阶段都是基于方法区中的存储结构</p></blockquote></li><li>元数据验证（语义分析）：保证不存在不符合语言规范的元数据信息。</li><li>字节码验证（并不能完全保证安全）：对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li><li>符号引用验证：发生在虚拟机将符号引用转化为直接引用阶段，确保解析动作可以正常执行。</li></ol><h4 id="1-3-准备"><a href="#1-3-准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h4><p>为类变量（被 static 修饰的变量，不包括实例变量）分配内存并设置类变量初始值（一般是零值）。</p><blockquote><p>通常情况下初始化零值，如果存在 ConstantValue 属性，则指定为 ConstantValue 属性的值。<br><code>public static int value = 123;</code>此代码 value 准备阶段之后的结果为0；<br><code>public static final int value = 123;</code>此代码 value 准备阶段之后的结果为123。</p></blockquote><h4 id="1-4-解析"><a href="#1-4-解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h4><p>将常量池中的符号引用替换为直接引用。</p><blockquote><p>除invokeddynamic指令，其余需要进行解析的字节码指令都会对第一次解析结果进行缓存。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。</p></blockquote><h4 id="1-5-初始化"><a href="#1-5-初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h4><p>执行类构造器<code>&lt;clinit&gt;()</code>方法。</p><ul><li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</li><li><code>&lt;clinit&gt;()</code>不需要显示调用父类的<code>&lt;clinit&gt;()</code>，由虚拟机保证父类<code>&lt;clinit&gt;()</code>执行。<br>第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object</code>。</li><li>父类中定义的静态语句块优于子类变量的复制操作。</li><li><code>&lt;clinit&gt;()</code>是非必需的（没有静态语句块和变量赋值操作）</li><li>接口不能使用静态语句块，但是可以对变量赋值。<br>只有父接口中定义的变量使用时，父接口才会初始化。</li><li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁、同步。</li></ul><h3 id="2-类加载器"><a href="#2-类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><h4 id="2-1-判断两个类相等"><a href="#2-1-判断两个类相等" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-判断两个类相等" class="headerlink" title="2.1 判断两个类相等"></a>2.1 判断两个类相等</h4><ol><li>使用相同类加载器</li><li>全限定名相同</li></ol><h4 id="2-2-双亲委派模型"><a href="#2-2-双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h4><p><img src="https://images2018.cnblogs.com/blog/1256203/201807/1256203-20180714171531925-1737231049.png" alt="image"></p><h5 id="双亲委派模型工作过程："><a href="#双亲委派模型工作过程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派模型工作过程：" class="headerlink" title="双亲委派模型工作过程："></a>双亲委派模型工作过程：</h5><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><blockquote><p>类加载器之间的父子关系不会以继承实现，而是使用组合的方式。</p></blockquote><h5 id="双亲委派模型的三次破坏"><a href="#双亲委派模型的三次破坏" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派模型的三次破坏" class="headerlink" title="双亲委派模型的三次破坏"></a>双亲委派模型的三次破坏</h5><ul><li>第一次破坏是<strong>在jdk 1.2之前，用户自定义的类加载器都是重写Classloader中的loadClass方法</strong>,这样就导致每个自定义的类加载器其实是在使用自己的loadClass方法中的加载机制来进行加载,这种模式当然是不符合双亲委派机制的，也是无法保证同一个类在jvm中的唯一性的。为了向前兼容，java官方<strong>在Classloader中添加了findClass方法</strong>,用户只需要重新这个findClass方法，在loadClass方法的逻辑里，如果父类加载失败的时候，才会调用自己的findClass方法来完成类加载，这样就保证了写出的类加载器是符合双亲委派机制的。</li><li>第二次的破坏是由模型本身的缺陷导致的，<strong>根类加载器加载了基础代码，但是基础代码中有可能调用了用户的代码</strong>，但是对于根类加载器而言是不认识用户的代码的。<blockquote><p>那么这时候java团队使用了一个不太优雅的设计：线程上下文类加载器。这个类加载器可以通过Thread类的setContextClassLoader方法进行设置,如果创建线程时还未设置，它就从父线程继承一个，如果在应用全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p></blockquote></li></ul><blockquote><p>利用这个线程上下文类加载器傅，父类加载器请求子类加载器去加载某些自己识别不了的类。</p></blockquote><blockquote><p>java中基本所有涉及spi的加载动作基本上都采用了这种方式，例如jndi，jdbc等。</p></blockquote><ul><li>第三次的破坏是因为<strong>用户对于程序的动态性追求，诸如：代码热替换，模块热部署</strong>。<br>目前业界Java模块化的标准是OSGI。而OSGI实现模块热部署的关键是他自己的类加载机制：每个程序模块(bundle)都有自己的类加载器，需要更换程序(bundle)的时候，连同类加载器一起替换，以实现代码的热部署。</li></ul><h2 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="heading-link"><i class="fas fa-link"></i></a><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h2><h3 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3><ul><li>包含<strong>局部变量表、操作数栈、动态连接和方法返回地址</strong>等信息。</li><li>编译时确定栈帧中的局部变量表大小。</li><li>一个栈帧需要分配多少内存不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</li><li>只有位于栈顶的栈帧（当前栈帧）才是有效的。</li></ul><h4 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h4><ul><li>以容量槽（Slot）为最小单位</li><li>每个Slot都应该能够存放一个boolean、byte、char、short、int、float、reference或returnAddress类型数据。</li><li>如果一个局部变量定义了但是没有赋初始值是不能使用的</li></ul><h4 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h4><ul><li>Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈</li></ul><h4 id="1-3-动态连接"><a href="#1-3-动态连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h4><p>指向运行时常量池中该栈帧所属方法的引用。<br><strong>静态解析</strong>：符号引用在类加载阶段或第一次使用时转化为直接引用。<br><strong>动态连接</strong>：符号引用在每一次运行期间转化为直接引用。</p><h4 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h4><p>方法正常退出时，调用者的<strong>PC计数器</strong>的值可以作为返回地址，栈帧中很可能会保存这个计数器的值。<br>方法异常退出时，返回地址通过<strong>异常处理器</strong>表来确定，栈帧中一般不会保存这部分信息。<br><strong>方法退出过程：</strong></p><ol><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值压入调用者栈帧的操作数栈</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li></ol><h3 id="2-方法调用"><a href="#2-方法调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><h4 id="2-1-解析"><a href="#2-1-解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h4><ul><li>只要能被 invokestatic 和 invokespecial 指令调用的方法都可以在解析阶段确定唯一的调用版本。</li><li>符合上述条件的的有<strong>静态方法、私有方法、实例构造器、父类方法</strong> 4 种。都称为<strong>非虚方法</strong>。其余方法为<strong>虚方法</strong>。<blockquote><p>final 方法也是非虚方法。</p></blockquote></li></ul><h4 id="2-2-分派（与多态特性有关）"><a href="#2-2-分派（与多态特性有关）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-分派（与多态特性有关）" class="headerlink" title="2.2 分派（与多态特性有关）"></a>2.2 分派（与多态特性有关）</h4><div class="table-container"><table><thead><tr><th>静态分派</th><th>动态分派</th></tr></thead><tbody><tr><td>编译阶段</td><td>运行阶段</td></tr><tr><td>重载</td><td>重写</td></tr><tr><td>多分派（关心静态类型与方法参数两个因素）</td><td>单分派（只关心方法接收者）</td></tr></tbody></table></div><h5 id="（1）静态分派（重载）"><a href="#（1）静态分派（重载）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）静态分派（重载）" class="headerlink" title="（1）静态分派（重载）"></a>（1）静态分派（重载）</h5><p>所有通过静态类型来定位方法执行版本的分派动作称为静态分派。</p><blockquote><ul><li>方法重载是静态分派的典型应用</li><li>静态分派发生在编译阶段</li></ul></blockquote><p><code>Human man = new Man();</code><br><code>Human</code>为变量的<strong>静态类型</strong>，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；<br><code>Man</code>为变量的<strong>实际类型</strong>，实际类型的变化结果在运行期才可以确定，编译期间不知道对象的实际类型。<br><strong>重载</strong>通过参数的<strong>静态类型而不是实际类型</strong>作为判定依据。</p><h5 id="（2）动态分派（重写）"><a href="#（2）动态分派（重写）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）动态分派（重写）" class="headerlink" title="（2）动态分派（重写）"></a>（2）动态分派（重写）</h5><p>运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><blockquote><p>根据操作数栈中的信息确定接受者的实际类型</p></blockquote><h5 id="（3）单分派与多分派"><a href="#（3）单分派与多分派" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）单分派与多分派" class="headerlink" title="（3）单分派与多分派"></a>（3）单分派与多分派</h5><p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong>。<br><strong>单分派</strong>是根据一个宗量对目标方法进行选择，<strong>多分派</strong>则是根据多个宗量对目标方法进行选择。<br><strong>静态分派</strong>属于<strong>多分派</strong>，<strong>动态分派</strong>属于<strong>单分派</strong>。</p><h5 id="（4）多分派的实现"><a href="#（4）多分派的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）多分派的实现" class="headerlink" title="（4）多分派的实现"></a>（4）多分派的实现</h5><p>为类在方法区中建立<strong>虚方法表</strong>，存放各个方法的实际入口地址。<br>如果子类重写了父类函数，虚方法表中存放指向子类实现版本的入口地址；否则，与父类相同方法的入口地址一致。</p><h2 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h2><h3 id="1-Java内存模型"><a href="#1-Java内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h3><div class="table-container"><table><thead><tr><th align="center">工作内存</th><th align="center">主内存</th></tr></thead><tbody><tr><td align="center">线程对变量读取、赋值等操作</td><td align="center">线程间变量值的传递</td></tr><tr><td align="center">虚拟机栈中的部分区域</td><td align="center">Java堆中的对象实例数据部分</td></tr></tbody></table></div><h4 id="1-1-内存间的交互操作"><a href="#1-1-内存间的交互操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-内存间的交互操作" class="headerlink" title="1.1 内存间的交互操作"></a>1.1 内存间的交互操作</h4><p><img src="https://img-blog.csdn.net/20180522220730109" alt="image"></p><ol><li>**lock(锁定)**：作用于主内存的变量，把一个变量标记为一条线程独占状态</li><li>**unlock(解锁)**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>**read(读取)**：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>**load(载入)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>**use(使用)**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>**assign(赋值)**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li><li>**store(存储)**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li><li>**write(写入)**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ol><h5 id="同步规则分析："><a href="#同步规则分析：" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步规则分析：" class="headerlink" title="同步规则分析："></a>同步规则分析：</h5><ol><li>不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li></ol><h4 id="2-3-volatile"><a href="#2-3-volatile" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-volatile" class="headerlink" title="2.3 volatile"></a>2.3 volatile</h4><h5 id="1-保证可见性，read与load、aggsin与store两两不分开。"><a href="#1-保证可见性，read与load、aggsin与store两两不分开。" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-保证可见性，read与load、aggsin与store两两不分开。" class="headerlink" title="1. 保证可见性，read与load、aggsin与store两两不分开。"></a>1. 保证可见性，read与load、aggsin与store两两不分开。</h5><h5 id="2-禁止指令重排序优化，内存屏障"><a href="#2-禁止指令重排序优化，内存屏障" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-禁止指令重排序优化，内存屏障" class="headerlink" title="2. 禁止指令重排序优化，内存屏障"></a>2. 禁止指令重排序优化，内存屏障</h5><h4 id="2-4-long与double型变量的特殊规则"><a href="#2-4-long与double型变量的特殊规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4-long与double型变量的特殊规则" class="headerlink" title="2.4 long与double型变量的特殊规则"></a>2.4 long与double型变量的特殊规则</h4><p>虚拟机不保证64位数据类型的load、store、read和write这四个操作的原子性。</p><blockquote><p>目前的商用虚拟机保证了64位数据的类型读写操作的原子性</p></blockquote><h4 id="2-5-原子性、可见性与有序性"><a href="#2-5-原子性、可见性与有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h4><h5 id="（1）原子性"><a href="#（1）原子性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h5><ul><li>基本数据类型具备原子性</li><li><code>sychronized</code> 关键字保证更大范围内的原子性</li></ul><h5 id="（2）可见性"><a href="#（2）可见性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）可见性" class="headerlink" title="（2）可见性"></a>（2）可见性</h5><ul><li><code>volatile</code>、<code>sychronized</code>和<code>final</code>三个关键字实现可见性。</li><li><code>final</code>关键字的可见性：<br>被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把<code>this</code>的引用传递出去，那在其他线程中就能看到 final 字段的值。</li></ul><h5 id="（3）有序性"><a href="#（3）有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h5><ul><li><code>volatile</code>和<code>sychronized</code>两个关键字实现有序性。</li><li>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</li></ul><h4 id="2-6-先行发生原则（happens-before）"><a href="#2-6-先行发生原则（happens-before）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-先行发生原则（happens-before）" class="headerlink" title="2.6 先行发生原则（happens-before）"></a>2.6 先行发生原则（happens-before）</h4><h5 id="（1）定义"><a href="#（1）定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li></ol><h5 id="（2）具体规则"><a href="#（2）具体规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）具体规则" class="headerlink" title="（2）具体规则"></a>（2）具体规则</h5><ol><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li><strong>程序中断规则</strong>：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li><li><strong>对象finalize规则</strong>：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li></ol><h3 id="Java与线程"><a href="#Java与线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><blockquote><p>在Java中，JDK1.2之前由用户线程实现，JDK1.2之后使用基于操作系统原生线程模型实现，win和linux都是用的一对一的线程模型（一条Java线程映射到一条轻量级进程中）。</p></blockquote><h4 id="1-线程的实现"><a href="#1-线程的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-线程的实现" class="headerlink" title="1. 线程的实现"></a>1. 线程的实现</h4><h5 id="1-1-使用内核线程实现"><a href="#1-1-使用内核线程实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-使用内核线程实现" class="headerlink" title="1.1 使用内核线程实现"></a>1.1 使用内核线程实现</h5><ul><li>不直接使用内核线程，而是使用内核线程的高级接口：轻量级进程。</li><li>轻量级进程与内核线程的数量比为 1 ：1。</li><li>轻量级进程消耗内核资源，一个系统支持的轻量级进程的数量是有限的。</li></ul><h5 id="1-2-使用用户线程实现（实现复杂，没有使用）"><a href="#1-2-使用用户线程实现（实现复杂，没有使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-使用用户线程实现（实现复杂，没有使用）" class="headerlink" title="1.2 使用用户线程实现（实现复杂，没有使用）"></a>1.2 使用用户线程实现（实现复杂，没有使用）</h5><ul><li>进程与用户线程之间是 1 ：N 的关系</li></ul><h5 id="1-3-使用用户线程加轻量级进程混合实现"><a href="#1-3-使用用户线程加轻量级进程混合实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-使用用户线程加轻量级进程混合实现" class="headerlink" title="1.3 使用用户线程加轻量级进程混合实现"></a>1.3 使用用户线程加轻量级进程混合实现</h5><ul><li>用户线程与轻量级进程之间是 N:M 的关系。</li></ul><h4 id="2-线程调度"><a href="#2-线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h4><ul><li>协同式线程调度：实现简单，但线程执行时间不可控</li><li>抢占式线程调度：Java一共10个优先级，但windows系统只有7个</li></ul><h4 id="3-状态转换"><a href="#3-状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-状态转换" class="headerlink" title="3. 状态转换"></a>3. 状态转换</h4><p><img src="https://pic2.zhimg.com/80/v2-326a2be9b86b1446d75b6f52f54c98fb_hd.jpg" alt="线程状态转移图"></p></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://fxbing.github.io">fxbing</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://fxbing.github.io/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/">http://fxbing.github.io/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://fxbing.github.io/tags/Java/">Java</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/08/06/2019-08-06-Pulsar%20Backlog/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Pulsar 源码阅读： Backlog</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/07/23/2019-07-23-Pulsar-Retention/"><span class="paginator-prev__text">Pulsar 源码阅读： Retention</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="disqus_thread"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.</span> <span class="toc-text">第三章 垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1. 对象是否存活</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">引用计数法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">可达性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">可以作为GC Roots的对象：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB%EF%BC%88JDK1-2%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2. 引用分类（JDK1.2实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-finalize-%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3. finalize()（不建议使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.4.</span> <span class="toc-text">4. 回收方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">废弃常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">无用的类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">5. 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">（1）标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">（2）复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">（3）标记整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">（4）分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HotSpot%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text">6. HotSpot算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">（1）枚举根节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%88SafePoint%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">（2）安全点（SafePoint）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%88Safe-Region%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">（3）安全区域（Safe Region）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">7. 垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Serial%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Client%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%B8%85%E7%90%86%E9%A6%96%E9%80%89%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">（1）Serial收集器（Client模式下新生代垃圾清理首选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89ParNew%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Server%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%B8%85%E7%90%86%E9%A6%96%E9%80%89%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">（2）ParNew收集器（Server模式下新生代垃圾清理首选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">（3）Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">（4）Serial Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">（5）Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.6.</span> <span class="toc-text">（6）CMS收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89G1%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88JDK1-7%EF%BC%89"><span class="toc-number">1.7.7.</span> <span class="toc-text">（7）G1收集器（JDK1.7）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.</span> <span class="toc-text">8. 内存分配与回收策略</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">第七章 虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E4%B8%94%E4%BB%85%E6%9C%89%E4%B8%8A%E9%9D%A2%E4%BA%94%E7%A7%8D%E6%83%85%E5%86%B5%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E6%88%90%E4%B8%BA%E4%B8%BB%E5%8A%A8%E5%BC%95%E7%94%A8%EF%BC%8C%E9%99%A4%E6%AD%A4%E4%B9%8B%E5%A4%96%EF%BC%8C%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E6%96%B9%E5%BC%8F%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%A7%B0%E4%B8%BA%E8%A2%AB%E5%8A%A8%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%AA%8C%E8%AF%81%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E4%BD%86%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%BF%85%E8%A6%81%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 验证（非常重要但不一定必要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%87%86%E5%A4%87"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2. 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%B1%BB%E7%9B%B8%E7%AD%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 判断两个类相等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">双亲委派模型工作过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E6%AC%A1%E7%A0%B4%E5%9D%8F"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">双亲委派模型的三次破坏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">第八章 虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">1. 运行时栈帧结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 动态连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 方法返回地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2. 方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%86%E6%B4%BE%EF%BC%88%E4%B8%8E%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7%E6%9C%89%E5%85%B3%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 分派（与多态特性有关）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%88%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">（1）静态分派（重载）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">（2）动态分派（重写）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8D%95%E5%88%86%E6%B4%BE%E4%B8%8E%E5%A4%9A%E5%88%86%E6%B4%BE"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">（3）单分派与多分派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A4%9A%E5%88%86%E6%B4%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">（4）多分派的实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">第十二章 Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1. Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 内存间的交互操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">同步规则分析：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-volatile"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.3 volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8Cread%E4%B8%8Eload%E3%80%81aggsin%E4%B8%8Estore%E4%B8%A4%E4%B8%A4%E4%B8%8D%E5%88%86%E5%BC%80%E3%80%82"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1. 保证可见性，read与load、aggsin与store两两不分开。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">2. 禁止指令重排序优化，内存屏障</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-long%E4%B8%8Edouble%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-number">4.1.3.</span> <span class="toc-text">2.4 long与double型变量的特殊规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.1.4.</span> <span class="toc-text">2.5 原子性、可见性与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">（1）原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">（2）可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">（3）有序性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99%EF%BC%88happens-before%EF%BC%89"><span class="toc-number">4.1.5.</span> <span class="toc-text">2.6 先行发生原则（happens-before）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">（1）定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B7%E4%BD%93%E8%A7%84%E5%88%99"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">（2）具体规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Java与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1.1 使用内核线程实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">1.2 使用用户线程实现（实现复杂，没有使用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">1.3 使用用户线程加轻量级进程混合实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. 状态转换</span></a></li></ol></li></ol></li></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/uploads/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">既然生活这么苦，那还不笑一笑让自己开心一点。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/fxbing" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>fxbing</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function loadDisqus(){var e,t,d;document.getElementById("disqus_thread")&&(window.DISQUS?DISQUS.reset({reload:!0,config:function(){this.page.url="http://fxbing.github.io/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/",this.page.identifier="2019/07/28/2019-07-28-深入理解JAVA虚拟机笔记/",this.page.title="《深入理解Java虚拟机》笔记"}}):(t=(e=document).createElement("script"),d=e.createElement("script"),t.src="https://fxbingBlog.disqus.com/count.js",t.id="dsq-count-scr",t.async=!0,(e.head||e.body).appendChild(t),d.src="https://fxbingBlog.disqus.com/embed.js",(e.head||e.body).appendChild(d)))}window.addEventListener("DOMContentLoaded",loadDisqus,!1)</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>