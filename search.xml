<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World, Hello Blog</title>
    <url>/2019/05/09/2019-05-09-hello-2019/</url>
    <content><![CDATA[
        <h1 id="开门啦"   >
          <a href="#开门啦" class="heading-link"><i class="fas fa-link"></i></a><a href="#开门啦" class="headerlink" title="开门啦"></a>开门啦</h1>
      <blockquote>
<p>万事开头难</p>
</blockquote>
<p>我的博客终于开通了，之后会在这里写一些东西，可能是一些想法，可能是一些笔记，也可能是一些技术文章，总之，希望我的博客可以发展起来！！！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar 源码阅读： Retention</title>
    <url>/2019/07/23/2019-07-23-Pulsar-Retention/</url>
    <content><![CDATA[<p>对于已经消费确认的消息，Pulsar 可以通过配置 Retention 策略决定保留的时间及大小。</p>
<p>具体参见官方文档：<span class="exturl"><a class="exturl__link"   href="https://pulsar.apache.org/docs/zh-CN/cookbooks-retention-expiry/#docsNav" >Message retention and expiry</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Pulsar 源码中有三个部分与 Retention 相关。</p>
<span id="more"></span>



        <h2 id="1-PersistentTopic"   >
          <a href="#1-PersistentTopic" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-PersistentTopic" class="headerlink" title="1. PersistentTopic"></a>1. PersistentTopic</h2>
      <p>在<strong>BrokerService</strong>启动之后，<code>this.startInactivityMonitor();</code>操作会对不活动任务进行定期清理，其中包括 GC 操作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkGC</span><span class="params">(<span class="keyword">int</span> gcIntervalInSeconds)</span> </span>&#123;</span><br><span class="line">        forEachTopic(topic -&gt; topic.checkGC(gcIntervalInSeconds));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>该操作会对 Broker 中的每个 Topic 进行 GC 检查清理的操作。</p>
<p>其中<code>checkGC()</code>为<code>PersistentTopic</code>类中的实现，如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            lastActive = System.nanoTime();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.nanoTime() - lastActive &lt; TimeUnit.SECONDS.toNanos(gcIntervalInSeconds)) &#123;</span><br><span class="line">            <span class="comment">// Gc interval did not expire yet</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldTopicBeRetained()) &#123;</span><br><span class="line">            <span class="comment">// Topic activity is still within the retention period</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>shouldTopicBeRetained()</code>函数会对需要 retention 的数据进行检查。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check whether the topic should be retained (based on time), even tough there are no producers/consumers and it&#x27;s</span></span><br><span class="line"><span class="comment">     * marked as inactive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldTopicBeRetained</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TopicName name = TopicName.get(topic);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从配置缓存中读取配置信息</span></span><br><span class="line">            Optional&lt;Policies&gt; policies = brokerService.pulsar().getConfigurationCache().policiesCache()</span><br><span class="line">                    .get(AdminResource.path(POLICIES, name.getNamespace()));</span><br><span class="line">            <span class="comment">// 如果没有配置信息，默认该 Topic 不需要 Retention ，清理。</span></span><br><span class="line">            <span class="comment">// 如果有配置信息，根据是否超过设定的 Retention 时间选择是否进行清理</span></span><br><span class="line">            <span class="keyword">return</span> policies.map(p -&gt; p.retention_policies).map(rp -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> retentionTime = TimeUnit.MINUTES.toNanos(rp.getRetentionTimeInMinutes());</span><br><span class="line">                <span class="keyword">return</span> retentionTime &lt; <span class="number">0</span> || (System.nanoTime() - lastActive) &lt; retentionTime;</span><br><span class="line">            &#125;).orElse(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;[&#123;&#125;] Error getting policies&quot;</span>, topic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Don&#x27;t delete in case we cannot get the policies</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>上面对是否到达 Retention 时间的检查用到了 <code>AbstractTopic</code> 类中的<code>lastActive</code>字段：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Timestamp of when this topic was last seen active</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastActive;</span><br></pre></td></tr></table></div></figure>

<p>该字段在每次移除<code>Producer</code>、移除订阅和执行<code>checkGC()</code>的时候进行更新。这里根据我的理解对两个问题进行解释：</p>
<ol>
<li><p>为什么只在移除的时候更新，而不再加入的时候更新？</p>
<p>lastActive指的是最后的存活时间，所以只有移除所有的producer、consumer之后才可能需要更新。</p>
</li>
<li><p>在每次移除Producer和consumer之后都进行更新，如果保证lastActive就代表了该Topic清空Producer和Consumer的时间？</p>
<p>shiyonglastActive并不能代表这个意思，首先lastActive只在判断是否需要进行GC和是否需要被保留的时候使用（后者是在前者之中调用的），在使用lastActive之前，会执行<code>isActive()</code>函数，该函数是对该Topic是否还有与其连接的Producer和Consumer，所有之后使用lastActive参数时已经保证了<code>isActive()</code>不成立，即：<strong>该Topic上已经不存在Producer和Consumer</strong>了。</p>
</li>
</ol>
<p>以上是BrokerService中进行Topic清理时对**<code>RetentionTime</code>**的使用，这一部分是在清理 Topic 之前根据 Retention 策略决定该 Topic 是否应该被清理。</p>

        <h2 id="2-ManagedLedgerImpl"   >
          <a href="#2-ManagedLedgerImpl" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-ManagedLedgerImpl" class="headerlink" title="2. ManagedLedgerImpl"></a>2. ManagedLedgerImpl</h2>
      <p>Ledger 有关的 Retention 特性是在**<code>ManagedLedgerImpl</code>**类中实现的，下面介绍该部分。</p>
<p>在启动BrokerService的时候，会设置<code>managedLedgerConfig</code>:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">managedLedgerConfig.setRetentionTime(retentionPolicies.getRetentionTimeInMinutes(), TimeUnit.MINUTES);</span><br><span class="line">managedLedgerConfig.setRetentionSizeInMB(retentionPolicies.getRetentionSizeInMB());</span><br></pre></td></tr></table></div></figure>

<p>在<code>ManagedLedgerImpl</code>类中，下面的函数会对已经完全被消费（所有消息已经被所有 Consumer 消费和确认过）Ledger进行周期性检查清理，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalTrimConsumedLedgers</span><span class="params">(CompletableFuture&lt;?&gt; promise)</span></span></span><br></pre></td></tr></table></div></figure>

<p>在上面的函数执行过程中，会通过<code>hasLedgerRetentionExpired</code>函数判断该Ledger是否需要被Retention。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasLedgerRetentionExpired</span><span class="params">(<span class="keyword">long</span> ledgerTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.getRetentionTimeMillis() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Negative retention time equates to infinite retention</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsedMs = clock.millis() - ledgerTimestamp;</span><br><span class="line">        <span class="keyword">return</span> elapsedMs &gt; config.getRetentionTimeMillis();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>其中<code>ledgerTimestamp</code>参数表示Ledger建立的时间。</p>

        <h2 id="3-NamespaceBase"   >
          <a href="#3-NamespaceBase" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-NamespaceBase" class="headerlink" title="3. NamespaceBase"></a>3. NamespaceBase</h2>
      <p>  还有一个用到<code>Retention</code>的地方是在<code>NamespaceBase</code>类中，可以对存储在Zookeeper中的<code>Retention</code>配置信息进行get和set，它通过<code>Namespaces</code>类中的Restful接口对外提供服务，client中的<code>cmd/namepaces</code>也是通过调用Restful接口实现的对Broker端的配置的修改。</p>
<p>  Retention 属于 Namespace 级别的配置，Namespace 只是一个逻辑上的概念，具体消息的存储是通过 Ledger 进行的（Ledger 是 Pulsar 中增加删除持久化信息的最小单位），所以 Retention 这一特性也是有 Ledger 部分实现的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar 源码阅读： Backlog</title>
    <url>/2019/08/06/2019-08-06-Pulsar%20Backlog/</url>
    <content><![CDATA[<p>对于<del>已经消费但是</del>没有确认的消息，Pulsar 可以通过配置 BacklogQuota 决定保留大小及丢弃策略。</p>
<p>具体参见官方文档：<span class="exturl"><a class="exturl__link"   href="https://pulsar.apache.org/docs/zh-CN/cookbooks-retention-expiry/#docsNav" >Message retention and expiry</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>当 Backlog 大小未达到限额时，不需要处理，当 Backlog 大小超限时，根据丢弃策略进行处理。</p>
<p>BacklogQuota 的丢弃策略一共有三种：</p>
<ol>
<li><code>producer_request_hold</code>：① 断开所有的 Producer ② 在新建 Producer 时进行检查，如果超出 BacklogQuota，则拒绝新建请求并等待超时（异步返回结果调用<code>get()</code>时才抛出异常）</li>
<li><code>producer_exception</code>：① 断开所有的 Producer ② 在新建 Producer 时进行检查，如果超出 BacklogQuota，则拒绝新建请求并抛出异常</li>
<li><code>consumer_backlog_eviction</code>：丢弃最早的 Backlog</li>
</ol>
<span id="more"></span>



        <h2 id="BacklogQuotaManager"   >
          <a href="#BacklogQuotaManager" class="heading-link"><i class="fas fa-link"></i></a><a href="#BacklogQuotaManager" class="headerlink" title="BacklogQuotaManager"></a>BacklogQuotaManager</h2>
      <p>Pulsar 中有<code>BacklogQuotaManager</code>用来进行 Backlog 处理，有下面几个关键函数。</p>

        <h3 id="handleExceededBacklogQuota"   >
          <a href="#handleExceededBacklogQuota" class="heading-link"><i class="fas fa-link"></i></a><a href="#handleExceededBacklogQuota" class="headerlink" title="handleExceededBacklogQuota"></a><code>handleExceededBacklogQuota</code></h3>
      <p>该函数用来处理 Backlog 超限的情况，对于<code>consumer_backlog_eviction</code>策略，调用<code>dropBacklog(persistentTopic, quota);</code>；对于<code>producer_exception</code>和<code>producer_request_hold</code>两种策略，调用<code>disconnectProducers(persistentTopic);</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExceededBacklogQuota</span><span class="params">(PersistentTopic persistentTopic)</span> </span>&#123;</span><br><span class="line">        TopicName topicName = TopicName.get(persistentTopic.getName());</span><br><span class="line">        String namespace = topicName.getNamespace();</span><br><span class="line">        String policyPath = AdminResource.path(POLICIES, namespace);</span><br><span class="line"></span><br><span class="line">        BacklogQuota quota = getBacklogQuota(namespace, policyPath);</span><br><span class="line">        log.info(<span class="string">&quot;Backlog quota exceeded for topic [&#123;&#125;]. Applying [&#123;&#125;] policy&quot;</span>, persistentTopic.getName(),</span><br><span class="line">                quota.getPolicy());</span><br><span class="line">        <span class="keyword">switch</span> (quota.getPolicy()) &#123;</span><br><span class="line">        <span class="keyword">case</span> consumer_backlog_eviction:</span><br><span class="line">            dropBacklog(persistentTopic, quota);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> producer_exception:</span><br><span class="line">        <span class="keyword">case</span> producer_request_hold:</span><br><span class="line">            disconnectProducers(persistentTopic);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>下面介绍<code>dropBacklog(persistentTopic, quota);</code>和<code>disconnectProducers(persistentTopic);</code>两个函数。</p>

        <h3 id="dropBacklog-persistentTopic-quota"   >
          <a href="#dropBacklog-persistentTopic-quota" class="heading-link"><i class="fas fa-link"></i></a><a href="#dropBacklog-persistentTopic-quota" class="headerlink" title="dropBacklog(persistentTopic, quota)"></a><code>dropBacklog(persistentTopic, quota)</code></h3>
      <p><code>dropBacklog(persistentTopic, quota);</code>函数负责在 Backlog 超限之后对 Backlog 中最早的消息进行丢弃，这里的丢弃实际是指<strong>向后移动未确认消息的起始标记</strong>（该 Topic 上最慢的 Consumer 的位置）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dropBacklog</span><span class="params">(PersistentTopic persistentTopic, BacklogQuota quota)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置丢弃比例为 0.9 ，即丢弃任务完成之后 Backlog 大小变为 Backlog 限额的 90%</span></span><br><span class="line">        <span class="keyword">double</span> reductionFactor = <span class="number">0.9</span>;</span><br><span class="line">        <span class="keyword">double</span> targetSize = reductionFactor * quota.getLimit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Backlog 大小的估计值，这里不直接使用 Ledger 的实际大小是因为 Ledger 不一定会被及时清理，实际大小会大于 Backlog 的大小</span></span><br><span class="line">        ManagedLedgerImpl mLedger = (ManagedLedgerImpl) persistentTopic.getManagedLedger();</span><br><span class="line">        <span class="keyword">long</span> backlogSize = mLedger.getEstimatedBacklogSize(); <span class="comment">//这个函数后面介绍</span></span><br><span class="line"></span><br><span class="line">        ManagedCursor previousSlowestConsumer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (backlogSize &gt; targetSize) &#123;</span><br><span class="line">            <span class="comment">// 最慢的 Consumer</span></span><br><span class="line">            ManagedCursor slowestConsumer = mLedger.getSlowestConsumer();</span><br><span class="line">            <span class="keyword">if</span> (slowestConsumer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要跳过的比例</span></span><br><span class="line">            <span class="keyword">double</span> messageSkipFactor = ((backlogSize - targetSize) / backlogSize);</span><br><span class="line">            <span class="comment">// Cursor 没有移动，不需要执行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slowestConsumer == previousSlowestConsumer) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算需要移动的距离</span></span><br><span class="line">            <span class="keyword">long</span> entriesInBacklog = slowestConsumer.getNumberOfEntriesInBacklog();</span><br><span class="line">            <span class="keyword">int</span> messagesToSkip = (<span class="keyword">int</span>) (messageSkipFactor * entriesInBacklog);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (messagesToSkip == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移动 slowestConsumer 位置</span></span><br><span class="line">                slowestConsumer.skipEntries(messagesToSkip, IndividualDeletedEntries.Include);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error skipping [&#123;&#125;] messages from slowest consumer : [&#123;&#125;]&quot;</span>, messagesToSkip,</span><br><span class="line">                        slowestConsumer.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动完成之后更新 backlogSize，再次执行上面的流程，确保移动之后 Backlog 没有再次超限</span></span><br><span class="line">            backlogSize = mLedger.getEstimatedBacklogSize();</span><br><span class="line">            previousSlowestConsumer = slowestConsumer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这里用到了一个<code>ManagedLedgerImpl</code>类中的一个函数<code>getEstimatedBacklogSize()</code>，用来估计 Backlog的大小。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEstimatedBacklogSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 未确认消息的起始标记</span></span><br><span class="line">        PositionImpl pos = getMarkDeletePositionOfSlowestConsumer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> size = <span class="number">0</span>; <span class="comment">// Backlog 大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> slowestConsumerLedgerId = pos.getLedgerId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取所有 Ledger 总大小</span></span><br><span class="line">                size = getTotalSize();</span><br><span class="line">                <span class="comment">// 减去没有及时清理的 Ledger 的大小</span></span><br><span class="line">                size -= ledgers.values().stream().filter(li -&gt; li.getLedgerId() &lt; slowestConsumerLedgerId)</span><br><span class="line">                        .mapToLong(li -&gt; li.getSize()).sum();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LedgerInfo ledgerInfo = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ledgerInfo = ledgers.get(pos.getLedgerId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ledgerInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 pos 指向的 Ledger 已经被删除，但是删除标记还没有更新（每次启动新的 manageLedger 时才会更新），就直接返回结果</span></span><br><span class="line">                <span class="keyword">if</span> (pos.compareTo(getMarkDeletePositionOfSlowestConsumer()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果删除标记已经更新，说明当前 pos 指向的 Ledger 已经被完全清理，则需要更新 pos 进行重试</span></span><br><span class="line">                pos = getMarkDeletePositionOfSlowestConsumer();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> numEntries = pos.getEntryId();</span><br><span class="line">            <span class="comment">// consumedLedgerSize()第三个参数需要作为除数，不能为 0</span></span><br><span class="line">            <span class="keyword">if</span> (ledgerInfo.getEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">                size -= consumedLedgerSize(currentLedgerSize, currentLedgerEntries, numEntries);</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size -= consumedLedgerSize(ledgerInfo.getSize(), ledgerInfo.getEntries(), numEntries);</span><br><span class="line">                <span class="keyword">return</span> size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">consumedLedgerSize</span><span class="params">(<span class="keyword">long</span> ledgerSize, <span class="keyword">long</span> ledgerEntries, <span class="keyword">long</span> consumedEntries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ledgerEntries &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 计算平均 Entry 大小</span></span><br><span class="line">        <span class="keyword">long</span> averageSize = ledgerSize / ledgerEntries;</span><br><span class="line">    	<span class="comment">// Entry Id 的起始编号为 -1，所以这里需要 +1</span></span><br><span class="line">        <span class="keyword">return</span> consumedEntries &gt;= <span class="number">0</span> ? (consumedEntries + <span class="number">1</span>) * averageSize : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="disconnectProducers-persistentTopic"   >
          <a href="#disconnectProducers-persistentTopic" class="heading-link"><i class="fas fa-link"></i></a><a href="#disconnectProducers-persistentTopic" class="headerlink" title="disconnectProducers(persistentTopic)"></a><code>disconnectProducers(persistentTopic)</code></h3>
      <p><code>disconnectProducers(persistentTopic);</code>函数负责在<code>producer_request_hold</code>和<code>producer_exception</code>两种模式下 Backlog 超限时断开与 Producer 的链接。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnectProducers</span><span class="params">(PersistentTopic persistentTopic)</span> </span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = Lists.newArrayList();</span><br><span class="line">        ConcurrentOpenHashSet&lt;Producer&gt; producers = persistentTopic.getProducers();</span><br><span class="line"></span><br><span class="line">        producers.forEach(producer -&gt; &#123;</span><br><span class="line">            futures.add(producer.disconnect());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureUtil.waitForAll(futures).thenRun(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;All producers on topic [&#123;&#125;] are disconnected&quot;</span>, persistentTopic.getName());</span><br><span class="line">        &#125;).exceptionally(exception -&gt; &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error in disconnecting producers on topic [&#123;&#125;] [&#123;&#125;]&quot;</span>, persistentTopic.getName(), exception);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="BacklogQuota-检查"   >
          <a href="#BacklogQuota-检查" class="heading-link"><i class="fas fa-link"></i></a><a href="#BacklogQuota-检查" class="headerlink" title="BacklogQuota 检查"></a>BacklogQuota 检查</h2>
      <p>BacklogQuota 有两种形式的检查，一种是<strong>周期性检查</strong>，另一种是<strong>创建 Producer 之前检查</strong>。</p>

        <h3 id="周期性检查"   >
          <a href="#周期性检查" class="heading-link"><i class="fas fa-link"></i></a><a href="#周期性检查" class="headerlink" title="周期性检查"></a>周期性检查</h3>
      <p>在<code>BrokerService</code>启动时，会启动<code>startBacklogQuotaChecker();</code>，<code>startBacklogQuotaChecker();</code>负责周期性执行<code>monitorBacklogQuota() </code>，对于 Backlog 超限的情况，会通过<code>BacklogQuotaManager</code>进行处理。</p>
 <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitorBacklogQuota</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        forEachTopic(topic -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (topic <span class="keyword">instanceof</span> PersistentTopic) &#123;</span><br><span class="line">                PersistentTopic persistentTopic = (PersistentTopic) topic;</span><br><span class="line">                <span class="keyword">if</span> (isBacklogExceeded(persistentTopic)) &#123;</span><br><span class="line">                    getBacklogQuotaManager().handleExceededBacklogQuota(persistentTopic);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;quota not exceeded for [&#123;&#125;]&quot;</span>, topic.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="创建-Producer-之前检查"   >
          <a href="#创建-Producer-之前检查" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建-Producer-之前检查" class="headerlink" title="创建 Producer 之前检查"></a>创建 Producer 之前检查</h3>
      <p>在 Broker 与 Client 对接的服务端<code>ServerCnx</code>上，收到建立 Producer 的触发之后，在创建 Producer 之前，会进行 BacklogQuota 检查。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (topic.isBacklogQuotaExceeded(producerName)) &#123;</span><br><span class="line">    IllegalStateException illegalStateException = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;Cannot create producer on topic with backlog quota exceeded&quot;</span>);</span><br><span class="line">    BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();</span><br><span class="line">    <span class="keyword">if</span> (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) &#123;</span><br><span class="line">        <span class="comment">// 返回 Error</span></span><br><span class="line">        ctx.writeAndFlush( Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,</span><br><span class="line">                        illegalStateException.getMessage()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) &#123;</span><br><span class="line">        <span class="comment">// 返回 Exception</span></span><br><span class="line">        ctx.writeAndFlush(Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededException,</span><br><span class="line">                illegalStateException.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    producerFuture.completeExceptionally(illegalStateException);</span><br><span class="line">    producers.remove(producerId, producerFuture);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里只进行<code>producer_request_hold</code>和<code>producer_exception</code>两种策略的处理，<code>consumer_backlog_eviction</code>只在周期性检查时进行处理。</p>
<p>对于<code>producer_request_hold</code>策略，返回 Error ，<code>ClientCnx</code>在收到 Error 之后，不会直接结束请求，会在 Future 任务超时或者调用<code>get()</code>时抛出<code>ProducerBlockedQuotaExceededError</code>异常。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(CommandError error)</span> </span>&#123;</span><br><span class="line">        checkArgument(state == State.Ready);</span><br><span class="line"></span><br><span class="line">        log.warn(<span class="string">&quot;&#123;&#125; Received error from server: &#123;&#125;&quot;</span>, ctx.channel(), error.getMessage());</span><br><span class="line">        <span class="keyword">long</span> requestId = error.getRequestId();</span><br><span class="line">        <span class="keyword">if</span> (error.getError() == ServerError.ProducerBlockedQuotaExceededError) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;&#123;&#125; Producer creation has been blocked because backlog quota exceeded for producer topic&quot;</span>,</span><br><span class="line">                    ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;ProducerResponse&gt; requestFuture = pendingRequests.remove(requestId);</span><br><span class="line">        <span class="keyword">if</span> (requestFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestFuture.completeExceptionally(getPulsarClientException(error.getError(), error.getMessage()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;&#123;&#125; Received unknown request id from server: &#123;&#125;&quot;</span>, ctx.channel(), error.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>对于<code>producer_exception</code>策略，直接返回<code>ProducerBlockedQuotaExceededException</code>异常。</p>
<p>以上就是对 Pulsar 代码中 BacklogQuota 机制的实现。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture 总结</title>
    <url>/2019/08/18/2019-08-18-CompletableFuture/</url>
    <content><![CDATA[<p><code>CompletableFuture</code> 是Java8 中新增的用来进行函数式异步编程的工具类。</p>
<p>最近学习源码的过程中看到有很多 <code>CompletableFuture</code> 的使用，感觉自己对这个类中的各个方法的使用场景和方法不是很熟悉，遂参考了下面几篇博客进行学习（本文大部分内容也都来自下面几篇博客）：</p>
<p><span class="exturl"><a class="exturl__link"   href="https://colobu.com/2016/02/29/Java-CompletableFuture/" >Java CompletableFuture 详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/59eae61b51882549fc512b34" >Java8新的异步编程方式 CompletableFuture(一)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" >Java8新的异步编程方式 CompletableFuture(二)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/59eae6e4f265da430e4e4cb5" >Java8新的异步编程方式 CompletableFuture(三)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>上面的博客介绍的比较详细，为了自己查阅回看的方便，这里对这些方法进行一下总结（这里只总结不举例，具体使用需要看上面的博客）。</p>
<span id="more"></span>



        <h2 id="Future接口"   >
          <a href="#Future接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2>
      <p><code>Feture</code> 接口包含五个方法，介绍如下：</p>
<ul>
<li><p><code>boolean cancel (boolean mayInterruptIfRunning)</code> 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</p>
</li>
<li><p><code>boolean isCancelled ()</code> 任务是否已经取消，任务正常完成前将其取消，则返回 <code>true</code></p>
</li>
<li><p><code>boolean isDone ()</code> 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回<code>true</code></p>
</li>
<li><p><code>V get () throws InterruptedException, ExecutionException</code>  等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</p>
</li>
<li><p><code>V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException </code>同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计 算超时，将抛出TimeoutException</p>
</li>
</ul>

        <h2 id="主动完成计算"   >
          <a href="#主动完成计算" class="heading-link"><i class="fas fa-link"></i></a><a href="#主动完成计算" class="headerlink" title="主动完成计算"></a>主动完成计算</h2>
      <p><code>CompletableFuture</code>实现了<code>CompletionStage</code>和<code>Future</code>两个接口。</p>

        <h4 id="通过阻塞或者轮询获得结果"   >
          <a href="#通过阻塞或者轮询获得结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过阻塞或者轮询获得结果" class="headerlink" title="通过阻塞或者轮询获得结果"></a>通过阻塞或者轮询获得结果</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>public T get()</code></td>
<td><code>Future</code>接口实现</td>
</tr>
<tr>
<td><code>public T get(long timeout, TimeUnit unit)</code></td>
<td><code>Future</code>接口实现</td>
</tr>
<tr>
<td><code>public T getNow(T valueIfAbsent)</code></td>
<td>如果结果已经计算完则返回结果或者抛出异常，否则返回给定的<code>valueIfAbsent</code>值。</td>
</tr>
<tr>
<td><code>public T join()</code></td>
<td>返回计算的结果或者抛出一个unchecked异常(CompletionException)</td>
</tr>
</tbody></table></div>
<blockquote>
<p><code>join()</code>和<code>get()</code>的区别是，<code>join()</code>只会抛出<strong>未检查异常</strong>（不需要使用<code>try...catch..</code>进行处理），而<code>get()</code>会抛出<strong>检查异常</strong>。</p>
</blockquote>

        <h4 id="异步获取结果"   >
          <a href="#异步获取结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步获取结果" class="headerlink" title="异步获取结果"></a>异步获取结果</h4>
      <blockquote>
<ul>
<li><p>下面两个函数的调用会立即执行，并且只能执行一次。</p>
</li>
<li><p>如果该任务已经执行完成，那么下面两个调用会无效，只能获取执行完成的结果。其实就是使任务立即结束（返回指定结果或者指定抛出异常）。</p>
</li>
<li><p>比较适合需要返回<code>CompletableFuture</code>的方法，先创建一个空的<code>CompletableFuture</code>，之后通过下面两个函数指定前面创建的<code>CompletableFuture</code>的返回值。</p>
</li>
</ul>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>complete(T t)</code></td>
<td>完成异步执行，并返回future的结果</td>
</tr>
<tr>
<td><code>completeExceptionally(Throwable ex)</code></td>
<td>异步执行不正常的结束</td>
</tr>
</tbody></table></div>

        <h2 id="静态工厂方法"   >
          <a href="#静态工厂方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2>
      <blockquote>
<p>run 和 supply 的主要区别是异步操作是否有返回值（下面列出的所有方法也基本都是按照<strong>是否有返回值</strong>分为两类）。</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>runAsync(Runnable runnable)</code></td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码。</td>
</tr>
<tr>
<td><code>runAsync(Runnable runnable, Executor executor)</code></td>
<td>使用指定的thread pool执行异步代码。</td>
</tr>
<tr>
<td><code>supplyAsync(Supplier&lt;U&gt; supplier)</code></td>
<td>使用ForkJoinPool.commonPool()作为它的线程池执行异步代码，异步操作有返回值。</td>
</tr>
<tr>
<td><code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></td>
<td>使用指定的thread pool执行异步代码，异步操作有返回值。</td>
</tr>
</tbody></table></div>
<blockquote>
<p>下面几乎所有的方法都是一式三份，三种方法的区别是</p>
<ul>
<li>直接在当前线程执行</li>
<li>换另一个线程（但是不指定线程）异步执行</li>
<li>指定线程执行</li>
</ul>
</blockquote>

        <h2 id="转换"   >
          <a href="#转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换" class="headerlink" title="转换"></a>转换</h2>
      <blockquote>
<p>相当于 map 操作</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenApply(Function&lt;? super T,? extends U&gt; fn)</code></td>
<td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture</td>
</tr>
<tr>
<td><code>thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</code></td>
<td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用ForkJoinPool</td>
</tr>
<tr>
<td><code>thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</code></td>
<td>接受一个Function&lt;? super T,? extends U&gt;参数用来转换CompletableFuture，使用指定的线程池</td>
</tr>
</tbody></table></div>
<blockquote>
<p>相当于 flatMap 操作</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</code></td>
<td>在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。</td>
</tr>
<tr>
<td><code>thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</code></td>
<td>在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn,Executor executor)</code></td>
<td>在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回CompletableFuture类型。使用指定的线程池。</td>
</tr>
</tbody></table></div>

        <h2 id="组合"   >
          <a href="#组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合" class="headerlink" title="组合"></a>组合</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td><code>thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的fn，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
</tbody></table></div>
<blockquote>
<p>thenAcceptBoth跟thenCombine类似，但是返回CompletableFuture类型。</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; action)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。</td>
</tr>
<tr>
<td><code>thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; action)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; action, Executor executor)</code></td>
<td>当两个CompletableFuture都正常完成后，执行提供的action，用它来组合另外一个CompletableFuture的结果。使用指定的线程池。</td>
</tr>
</tbody></table></div>

        <h2 id="计算结果完成时的处理"   >
          <a href="#计算结果完成时的处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算结果完成时的处理" class="headerlink" title="计算结果完成时的处理"></a>计算结果完成时的处理</h2>
      <blockquote>
<ul>
<li><code>Action</code>的类型是<code>BiConsumer&lt;? super T,? super Throwable&gt;</code>，它可以处理正常的计算结果，或者异常情况。</li>
<li>方法不以<code>Async</code>结尾，意味着<code>Action</code>使用相同的线程执行，而<code>Async</code>可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行</li>
</ul>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</code></td>
<td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。</td>
</tr>
<tr>
<td><code>whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</code></td>
<td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</code></td>
<td>当CompletableFuture完成计算结果时对结果进行处理，或者当CompletableFuture产生异常的时候对异常进行处理。使用指定的线程池。</td>
</tr>
</tbody></table></div>
<blockquote>
<p><code>handle()</code>相当于whenComplete()+转换。</p>
<p><code>handle()</code>也可以理解为和<code>thenApply()</code>的含义更为相似，但是比<code>thenApply()</code>增加异常处理的功能。</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code></td>
<td>当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn</td>
</tr>
<tr>
<td><code>handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code></td>
<td>当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</code></td>
<td>当CompletableFuture完成计算结果或者抛出异常的时候，执行提供的fn，使用指定的线程池。</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>exceptionally(Function fn)</code></td>
<td>只有当CompletableFuture抛出异常的时候，才会触发这个exceptionally的计算，调用function计算值。</td>
</tr>
</tbody></table></div>

        <h2 id="纯消费"   >
          <a href="#纯消费" class="heading-link"><i class="fas fa-link"></i></a><a href="#纯消费" class="headerlink" title="纯消费"></a>纯消费</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenAccept(Consumer&lt;? super T&gt; action)</code></td>
<td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
<tr>
<td><code>thenAcceptAsync(Consumer&lt;? super T&gt; action)</code></td>
<td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值，使用ForkJoinPool。</td>
</tr>
<tr>
<td><code>thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</code></td>
<td>当CompletableFuture完成计算结果，只对结果执行Action，而不返回新的计算值</td>
</tr>
</tbody></table></div>

        <h2 id="Either"   >
          <a href="#Either" class="heading-link"><i class="fas fa-link"></i></a><a href="#Either" class="headerlink" title="Either"></a>Either</h2>
      <blockquote>
<p>Either 表示的是两个CompletableFuture，当其中任意一个CompletableFuture计算完成的时候就会执行。</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</code></td>
<td>当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。</td>
</tr>
<tr>
<td><code>acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</code></td>
<td>当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用ForkJoinPool</td>
</tr>
<tr>
<td><code>acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</code></td>
<td>当任意一个CompletableFuture完成的时候，action这个消费者就会被执行。使用指定的线程池</td>
</tr>
</tbody></table></div>
<blockquote>
<p><code>applyToEither()</code> 是<code>acceptEither()</code>的哥哥. 当两个future其中一个完成后，后者用于只是简单地调用一些代码，<code>applyToEither()</code>会返回一个新的future. 这个future是在前面两个future其中一个完成后进行执行完成。</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</code></td>
<td>当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<U>的计算结果。</td>
</tr>
<tr>
<td><code>applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</code></td>
<td>当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<U>的计算结果。使用ForkJoinPool</td>
</tr>
<tr>
<td><code>applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</code></td>
<td>当任意一个CompletableFuture完成的时候，fn会被执行，它的返回值会当作新的CompletableFuture<U>的计算结果。使用指定的线程池</td>
</tr>
</tbody></table></div>

        <h2 id="其他方法"   >
          <a href="#其他方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>allOf(CompletableFuture&lt;?&gt;... cfs)</code></td>
<td>在所有Future对象完成后结束，并返回一个future。</td>
</tr>
<tr>
<td><code>anyOf(CompletableFuture&lt;?&gt;... cfs)</code></td>
<td>在任何一个Future对象结束后结束，并返回一个future。</td>
</tr>
</tbody></table></div>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-06-记一次线上服务内存泄漏问题排查</title>
    <url>/2021/05/06/2021-05-06-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<span id="more"></span>


        <h2 id="问题发现"   >
          <a href="#问题发现" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2>
      
        <h2 id="排查过程"   >
          <a href="#排查过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2>
      
        <h2 id="问题修复-amp-总结"   >
          <a href="#问题修复-amp-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题修复-amp-总结" class="headerlink" title="问题修复&amp;总结"></a>问题修复&amp;总结</h2>
      ]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05-08-记一次kafka宕机问题排查</title>
    <url>/2021/05/08/2021-05-08-%E8%AE%B0%E4%B8%80%E6%AC%A1kafka%E5%AE%95%E6%9C%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p><img src="test.png"></p>
<span id="more"></span>


        <h2 id="问题发现"   >
          <a href="#问题发现" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2>
      
        <h2 id="排查过程"   >
          <a href="#排查过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2>
      
        <h2 id="问题修复-amp-总结"   >
          <a href="#问题修复-amp-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题修复-amp-总结" class="headerlink" title="问题修复&amp;总结"></a>问题修复&amp;总结</h2>
      ]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
        <tag>kafka</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <url>/2019/07/28/2019-07-28-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>阅读了《深入理解Java虚拟机》的部分章节，并做了一些简单的笔记，不是很详细，但是可以方便自己查阅。</p>
<span id="more"></span>



        <h2 id="第三章-垃圾收集器与内存分配策略"   >
          <a href="#第三章-垃圾收集器与内存分配策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2>
      
        <h3 id="1-对象是否存活"   >
          <a href="#1-对象是否存活" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-对象是否存活" class="headerlink" title="1. 对象是否存活"></a>1. 对象是否存活</h3>
      
        <h4 id="引用计数法："   >
          <a href="#引用计数法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用计数法：" class="headerlink" title="引用计数法："></a>引用计数法：</h4>
      <p>很难解决对象间的循环引用</p>

        <h4 id="可达性分析"   >
          <a href="#可达性分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4>
      
        <h5 id="可以作为GC-Roots的对象："   >
          <a href="#可以作为GC-Roots的对象：" class="heading-link"><i class="fas fa-link"></i></a><a href="#可以作为GC-Roots的对象：" class="headerlink" title="可以作为GC Roots的对象："></a>可以作为GC Roots的对象：</h5>
      <ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>

        <h3 id="2-引用分类（JDK1-2实现）"   >
          <a href="#2-引用分类（JDK1-2实现）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-引用分类（JDK1-2实现）" class="headerlink" title="2. 引用分类（JDK1.2实现）"></a>2. 引用分类（JDK1.2实现）</h3>
      <ul>
<li><strong>强引用</strong>：永远不回收</li>
<li><strong>软引用SoftReference</strong>（有用但非必须）：内存溢出之前回收</li>
<li><strong>弱引用WeakReference</strong>（非必须）：GC时回收</li>
<li><strong>虚引用PhantomReference</strong>（幽灵引用/幻影引用）：目的是能在这个对象被收集器回收时收到一个系统通知</li>
</ul>

        <h3 id="3-finalize-（不建议使用）"   >
          <a href="#3-finalize-（不建议使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-finalize-（不建议使用）" class="headerlink" title="3. finalize()（不建议使用）"></a>3. finalize()（不建议使用）</h3>
      <blockquote>
<p>判断对象是否死亡会经历<strong>两次标记</strong>过程：<br>①判断是否与GC Roots相连；<br>②执行finalize()（对象没有覆盖finalize()或finalize()已经被调用过一次时，虚拟机认为没必要执行finalize()，不会进行第二次标记）。</p>
</blockquote>
<ul>
<li>被调用时会放在由虚拟机自动创建的、低优先级的队列<strong>F-Queue</strong>中</li>
<li>finalize()是对象唯一的自救机会，例如：在finalize()中将this赋值给某个类变量或者对象的成员变量</li>
<li>运行代价高昂，不确定性大、无法保证各个对象的调用顺序</li>
<li>finalize()能做的所有工作使用try-finally或者其他方式可以做得更好、更及时</li>
</ul>

        <h3 id="4-回收方法区"   >
          <a href="#4-回收方法区" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-回收方法区" class="headerlink" title="4. 回收方法区"></a>4. 回收方法区</h3>
      
        <h5 id="废弃常量"   >
          <a href="#废弃常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h5>
      <p>与Java堆的回收逻辑类似</p>

        <h5 id="无用的类"   >
          <a href="#无用的类" class="heading-link"><i class="fas fa-link"></i></a><a href="#无用的类" class="headerlink" title="无用的类"></a>无用的类</h5>
      <ul>
<li>该类的所有实例已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>

        <h3 id="5-垃圾收集算法"   >
          <a href="#5-垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-垃圾收集算法" class="headerlink" title="5. 垃圾收集算法"></a>5. 垃圾收集算法</h3>
      
        <h4 id="（1）标记清除算法"   >
          <a href="#（1）标记清除算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）标记清除算法" class="headerlink" title="（1）标记清除算法"></a>（1）标记清除算法</h4>
      <ul>
<li>效率不高</li>
<li>会大量不连续内存碎片</li>
</ul>

        <h4 id="（2）复制算法"   >
          <a href="#（2）复制算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）复制算法" class="headerlink" title="（2）复制算法"></a>（2）复制算法</h4>
      <ul>
<li>内存缩小为原来的一半</li>
<li>HotSpot默认的Eden与Survivor的大小比例为8:1</li>
<li>没有办法保证每次回收都只有不多于10%的对象存活。当Survivor空间不够用时，需要依赖老年代进行<strong>分配担保</strong>。<blockquote>
<p>分配担保：当Survivor空间不能放下上一次 YGC 之后存活的对象时，这些对象直接通过分配担保机制进入老年代。</p>
</blockquote>
</li>
</ul>

        <h4 id="（3）标记整理算法"   >
          <a href="#（3）标记整理算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）标记整理算法" class="headerlink" title="（3）标记整理算法"></a>（3）标记整理算法</h4>
      
        <h4 id="（4）分代收集算法"   >
          <a href="#（4）分代收集算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）分代收集算法" class="headerlink" title="（4）分代收集算法"></a>（4）分代收集算法</h4>
      <p>新生代每次垃圾收集都会有大量对象死去，少量存活，所以采用复制算法。<br>老年代对象存活率高、没有额外的空间对它进行担保，必须使用“标记-清理”或者“标记-整理”算法。</p>

        <h3 id="6-HotSpot算法实现"   >
          <a href="#6-HotSpot算法实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-HotSpot算法实现" class="headerlink" title="6. HotSpot算法实现"></a>6. HotSpot算法实现</h3>
      
        <h4 id="（1）枚举根节点"   >
          <a href="#（1）枚举根节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）枚举根节点" class="headerlink" title="（1）枚举根节点"></a>（1）枚举根节点</h4>
      <ul>
<li>Java虚拟机使用准确式GC（必须确定一个变量是引用还是真正的数据）</li>
<li>虚拟机停顿之后不需要检查所有的执行上下文和全局的引用位置。</li>
<li>类加载完成时计算出什么偏移量上是什么类型的数据，JIT编译时在特定位置（<strong>安全点</strong>）记录<strong>OopMap</strong>数据结构（指明栈和寄存器哪些位置是引用）</li>
</ul>

        <h4 id="（2）安全点（SafePoint）"   >
          <a href="#（2）安全点（SafePoint）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）安全点（SafePoint）" class="headerlink" title="（2）安全点（SafePoint）"></a>（2）安全点（SafePoint）</h4>
      <ul>
<li>程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停。</li>
<li><strong>安全点选定原则</strong>：是否具有让程序<strong>长时间执行</strong>的特征</li>
<li><strong>长时间执行</strong>：指令序列复用（如：方法调用、循环跳转、异常跳转）</li>
<li><strong>抢先式中断（已经被弃用）</strong>：所有线程中断，不在安全点的线程恢复执行。  </li>
</ul>
<p><strong>主动式中断</strong>：在安全点设置中断标志，程序执行到安全点时主动轮询这个标志，判断是否需要进行中断。</p>

        <h4 id="（3）安全区域（Safe-Region）"   >
          <a href="#（3）安全区域（Safe-Region）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）安全区域（Safe-Region）" class="headerlink" title="（3）安全区域（Safe Region）"></a>（3）安全区域（Safe Region）</h4>
      <ul>
<li>定义：一段代码中，引用关系不会发生变化。（线程处于Sleep或Blocked状态）</li>
<li>线程执行到Safe Region时，标识自己进入Safe Region状态；<br>JVM GC时不管Safe Region状态的线程；<br>当线程离开Safe Region状态时，检查系统是否完成了根节点枚举或整个GC过程；<br>如果完成了，那线程继续执行，否则，必须等待收到可以安全离开Safe Region的信号为止。</li>
</ul>

        <h3 id="7-垃圾收集器"   >
          <a href="#7-垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-垃圾收集器" class="headerlink" title="7. 垃圾收集器"></a>7. 垃圾收集器</h3>
      <p>连线代表可以组合使用。<br><img src="https://i.bmp.ovh/imgs/2019/05/8e139eb7578dd5fc.jpg"></p>

        <h4 id="（1）Serial收集器（Client模式下新生代垃圾清理首选）"   >
          <a href="#（1）Serial收集器（Client模式下新生代垃圾清理首选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）Serial收集器（Client模式下新生代垃圾清理首选）" class="headerlink" title="（1）Serial收集器（Client模式下新生代垃圾清理首选）"></a>（1）Serial收集器（Client模式下新生代垃圾清理首选）</h4>
      <ul>
<li>进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</li>
<li>Serial/Serial Old收集器在新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</li>
</ul>

        <h4 id="（2）ParNew收集器（Server模式下新生代垃圾清理首选）"   >
          <a href="#（2）ParNew收集器（Server模式下新生代垃圾清理首选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）ParNew收集器（Server模式下新生代垃圾清理首选）" class="headerlink" title="（2）ParNew收集器（Server模式下新生代垃圾清理首选）"></a>（2）ParNew收集器（Server模式下新生代垃圾清理首选）</h4>
      <ul>
<li>多线程版本的Serial收集器</li>
<li>第一款真正意义上的<strong>并发</strong>收集器</li>
<li>默认开启的收集线程数与CPU的数量相同</li>
</ul>

        <h4 id="（3）Parallel-Scavenge收集器"   >
          <a href="#（3）Parallel-Scavenge收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h4>
      <ul>
<li>目标：达到一个可控制的吞吐量。（吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)）</li>
<li>适合在后台运算而不需要太多交互的任务</li>
<li>可以设置最大垃圾收集停段时间（-XX:MaxGCPauseMillis）和吞吐量大小（-XX:GCTimeRatio）</li>
<li>可以开启-XX:UseAdaptiveSizePolicy，之后虚拟机根据系统运行状况自动设置新生代大小、Eden与Survivor比例、晋升老年代对象大小等细节参数。（<strong>GC自适应的调节策略</strong>）</li>
</ul>

        <h4 id="（4）Serial-Old收集器"   >
          <a href="#（4）Serial-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h4>
      
        <h4 id="（5）Parallel-Old收集器"   >
          <a href="#（5）Parallel-Old收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h4>
      
        <h4 id="（6）CMS收集器"   >
          <a href="#（6）CMS收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h4>
      <ul>
<li>四个步骤：<br>a: 初始标记（停顿）：记录与GC Roots直接相连的对象<br>b: 并发标记：GC Roots Tracing<br>c: 重新标记（停顿更长）：修正并发标记期间因用户程序继续运作而导致的标记产生变动的记录<br>d: 并发清除</li>
<li>对 CPU 资源敏感</li>
<li>无法处理<strong>浮动垃圾</strong>（并发清除阶段用户程序产生的新的垃圾，需要等下次GC时再进行清理），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。（不能等老年代被填满之后进行清理，需要为并发清除期间用户程序的执行预留空间）</li>
<li>空间碎片过多</li>
</ul>

        <h4 id="（7）G1收集器（JDK1-7）"   >
          <a href="#（7）G1收集器（JDK1-7）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（7）G1收集器（JDK1-7）" class="headerlink" title="（7）G1收集器（JDK1.7）"></a>（7）G1收集器（JDK1.7）</h4>
      <ul>
<li>并行与并发</li>
<li>分代收集</li>
<li><strong>空间整合</strong>：从整体上看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制“算法实现的。</li>
<li><strong>可预测的停顿</strong>：使用者可以指定垃圾收集上消耗的时间不得超过 M 毫秒。</li>
<li>分配的对象会记录在 Remembered Set 中，内存回收时再GC根节点的枚举范围中加入 Remembered Set ，确保不对全堆扫描也不会有泄露。</li>
<li>不计算维护 Remembered Set 的过程，可以分为以下几个步骤：<br>a: 初始标记<br>b: 并发标记<br>c: 最终标记：并发标记期间对象变化记录在线程 Remembered Set Logs 中，该阶段将 Remembered Set Logs 整合到 Remembered Set 中。<br>d: 筛选回收：根据用户期望的 GC 停顿时间制定回收计划。</li>
</ul>

        <h3 id="8-内存分配与回收策略"   >
          <a href="#8-内存分配与回收策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-内存分配与回收策略" class="headerlink" title="8. 内存分配与回收策略"></a>8. 内存分配与回收策略</h3>
      <ul>
<li><strong>对象优先在Eden分配</strong><blockquote>
<p>新生代 GC （Minor GC）：非常频繁，回收速度也比较块。<br>老年代 GC （Major GC / Full GC）：伴随至少一次的 Minor GC ， 比 Minor GC 慢10倍以上。</p>
</blockquote>
</li>
<li><strong>大对象直接进入老年代</strong></li>
<li><strong>长期存活的对象将进入老年代</strong>（可以通过 -XX:MaxTenuringThreshold 参数进行设置，默认执行完<strong>15</strong>次 Minor GC）</li>
<li><strong>动态对象年龄判断</strong>：如果在 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li>
<li><strong>空间分配担保</strong>：在进行 Minor GC 之前会执行下面的流程，<br>a: 检查<strong>老年代最大连续可用空间是否大于新生代所有对象总空间</strong>，如果是 Minor GC 可以确保安全，否则， 执行b；<br>b: 查看 HandlePromotionFailure 设置的值是否允许担保失败，如果是，执行c，否则，执行 Full GC；<br>c: 检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</strong>，如果是，尝试一次 Minor GC （可能存在风险），否则，将 HandlePromotionFailure 设置为不允许冒险，改为进行一次 Full GC。</li>
</ul>

        <h2 id="第七章-虚拟机类加载机制"   >
          <a href="#第七章-虚拟机类加载机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2>
      
        <h3 id="1-类的加载过程"   >
          <a href="#1-类的加载过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h3>
      <p><img src="https://i.bmp.ovh/imgs/2019/05/ab251c96094d3f7d.png">  </p>
<ul>
<li>按顺序按部就班的开始（不是结束，一个阶段中调用激活另一个阶段），解析阶段可以在初始化之后再开始（动态绑定）</li>
<li>Java虚拟机规定的必须进行<strong>初始化</strong>的5种情况：<br>（1） 遇到 new、getstatic、putstatic、invokestatic这4条字节码指令（对应使用 <strong>new 关键字实例化对象</strong>、<strong>读取或设置类的静态字段</strong>（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）以及<strong>调用一个类的静态方法</strong>几种情况）<br>（2） 反射调用。<br>（3） 初始化一个类时，如果父类没有进行过初始化，需要先触发父类初始化。<br>（4） 虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的类），虚拟机会先初始化主类。<br>（5） 但是用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例后解析结果 REF_putStatic , REF_getStatic , REF_invokeStatic 的方法句柄时，当改方法句柄对应的类没有初始化时，需要初始化该类。<blockquote>
<p>接口初始化时并不要求其父类接口全部都初始化完成，只有在真正使用到父类接口时才会初始化。</p>
</blockquote>
</li>
</ul>
<blockquote>

        <h5 id="有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。"   >
          <a href="#有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。" class="heading-link"><i class="fas fa-link"></i></a><a href="#有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。" class="headerlink" title="有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。"></a>有且仅有上面五种情况会触发初始化，成为主动引用，除此之外，其他所有方式都不会触发初始化，称为被动引用。</h5>
      <p>被动引用举例：  </p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类的初始化。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
</blockquote>

        <h4 id="1-1-加载"   >
          <a href="#1-1-加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h4>
      <ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流<blockquote>
<p>获取途径：ZIP包（JAR、EAR、WAR）、网络（Applet）、运行时计算生成（动态代理）、其他文件（JSP应用）、数据库</p>
</blockquote>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<blockquote>
<ul>
<li>非数组类型使用引导类加载器或者用户自定义类加载器进行加载</li>
<li>数组的组件类型（去掉一个维度之后的类型）是引用类型，则按照普通类加载过程加载；不是引用类型，标记为与引导类加载器关联。</li>
<li>数组类可见性与组件类型可见性一致。如果组件类型不是引用类型，可见性默认为 public 。</li>
</ul>
</blockquote>
</li>
</ol>

        <h4 id="1-2-验证（非常重要但不一定必要）"   >
          <a href="#1-2-验证（非常重要但不一定必要）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-验证（非常重要但不一定必要）" class="headerlink" title="1.2 验证（非常重要但不一定必要）"></a>1.2 验证（非常重要但不一定必要）</h4>
      <ol>
<li>文件格式验证：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。<blockquote>
<p>经过此验证之后字节流才会进入内存方法区，后面3个验证阶段都是基于方法区中的存储结构</p>
</blockquote>
</li>
<li>元数据验证（语义分析）：保证不存在不符合语言规范的元数据信息。</li>
<li>字节码验证（并不能完全保证安全）：对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li>符号引用验证：发生在虚拟机将符号引用转化为直接引用阶段，确保解析动作可以正常执行。</li>
</ol>

        <h4 id="1-3-准备"   >
          <a href="#1-3-准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h4>
      <p>为类变量（被 static 修饰的变量，不包括实例变量）分配内存并设置类变量初始值（一般是零值）。</p>
<blockquote>
<p>通常情况下初始化零值，如果存在 ConstantValue 属性，则指定为 ConstantValue 属性的值。<br><code>public static int value = 123;</code>此代码 value 准备阶段之后的结果为0；<br><code>public static final int value = 123;</code>此代码 value 准备阶段之后的结果为123。</p>
</blockquote>

        <h4 id="1-4-解析"   >
          <a href="#1-4-解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h4>
      <p>将常量池中的符号引用替换为直接引用。</p>
<blockquote>
<p>除invokeddynamic指令，其余需要进行解析的字节码指令都会对第一次解析结果进行缓存。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用进行。</p>
</blockquote>

        <h4 id="1-5-初始化"   >
          <a href="#1-5-初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h4>
      <p>执行类构造器<code>&lt;clinit&gt;()</code>方法。</p>
<ul>
<li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</li>
<li><code>&lt;clinit&gt;()</code>不需要显示调用父类的<code>&lt;clinit&gt;()</code>，由虚拟机保证父类<code>&lt;clinit&gt;()</code>执行。<br>第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object</code>。</li>
<li>父类中定义的静态语句块优于子类变量的复制操作。</li>
<li><code>&lt;clinit&gt;()</code>是非必需的（没有静态语句块和变量赋值操作）</li>
<li>接口不能使用静态语句块，但是可以对变量赋值。<br>只有父接口中定义的变量使用时，父接口才会初始化。</li>
<li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁、同步。</li>
</ul>

        <h3 id="2-类加载器"   >
          <a href="#2-类加载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3>
      
        <h4 id="2-1-判断两个类相等"   >
          <a href="#2-1-判断两个类相等" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-判断两个类相等" class="headerlink" title="2.1 判断两个类相等"></a>2.1 判断两个类相等</h4>
      <ol>
<li>使用相同类加载器</li>
<li>全限定名相同</li>
</ol>

        <h4 id="2-2-双亲委派模型"   >
          <a href="#2-2-双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h4>
      <p><img src="https://images2018.cnblogs.com/blog/1256203/201807/1256203-20180714171531925-1737231049.png" alt="image"></p>

        <h5 id="双亲委派模型工作过程："   >
          <a href="#双亲委派模型工作过程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派模型工作过程：" class="headerlink" title="双亲委派模型工作过程："></a>双亲委派模型工作过程：</h5>
      <p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<blockquote>
<p>类加载器之间的父子关系不会以继承实现，而是使用组合的方式。</p>
</blockquote>

        <h5 id="双亲委派模型的三次破坏"   >
          <a href="#双亲委派模型的三次破坏" class="heading-link"><i class="fas fa-link"></i></a><a href="#双亲委派模型的三次破坏" class="headerlink" title="双亲委派模型的三次破坏"></a>双亲委派模型的三次破坏</h5>
      <ul>
<li>第一次破坏是<strong>在jdk 1.2之前，用户自定义的类加载器都是重写Classloader中的loadClass方法</strong>,这样就导致每个自定义的类加载器其实是在使用自己的loadClass方法中的加载机制来进行加载,这种模式当然是不符合双亲委派机制的，也是无法保证同一个类在jvm中的唯一性的。为了向前兼容，java官方<strong>在Classloader中添加了findClass方法</strong>,用户只需要重新这个findClass方法，在loadClass方法的逻辑里，如果父类加载失败的时候，才会调用自己的findClass方法来完成类加载，这样就保证了写出的类加载器是符合双亲委派机制的。</li>
<li>第二次的破坏是由模型本身的缺陷导致的，<strong>根类加载器加载了基础代码，但是基础代码中有可能调用了用户的代码</strong>，但是对于根类加载器而言是不认识用户的代码的。<blockquote>
<p>那么这时候java团队使用了一个不太优雅的设计：线程上下文类加载器。这个类加载器可以通过Thread类的setContextClassLoader方法进行设置,如果创建线程时还未设置，它就从父线程继承一个，如果在应用全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>利用这个线程上下文类加载器傅，父类加载器请求子类加载器去加载某些自己识别不了的类。</p>
</blockquote>
<blockquote>
<p>java中基本所有涉及spi的加载动作基本上都采用了这种方式，例如jndi，jdbc等。</p>
</blockquote>
<ul>
<li>第三次的破坏是因为<strong>用户对于程序的动态性追求，诸如：代码热替换，模块热部署</strong>。<br>目前业界Java模块化的标准是OSGI。而OSGI实现模块热部署的关键是他自己的类加载机制：每个程序模块(bundle)都有自己的类加载器，需要更换程序(bundle)的时候，连同类加载器一起替换，以实现代码的热部署。</li>
</ul>

        <h2 id="第八章-虚拟机字节码执行引擎"   >
          <a href="#第八章-虚拟机字节码执行引擎" class="heading-link"><i class="fas fa-link"></i></a><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h2>
      
        <h3 id="1-运行时栈帧结构"   >
          <a href="#1-运行时栈帧结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3>
      <ul>
<li>包含<strong>局部变量表、操作数栈、动态连接和方法返回地址</strong>等信息。</li>
<li>编译时确定栈帧中的局部变量表大小。</li>
<li>一个栈帧需要分配多少内存不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</li>
<li>只有位于栈顶的栈帧（当前栈帧）才是有效的。</li>
</ul>

        <h4 id="1-1-局部变量表"   >
          <a href="#1-1-局部变量表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h4>
      <ul>
<li>以容量槽（Slot）为最小单位</li>
<li>每个Slot都应该能够存放一个boolean、byte、char、short、int、float、reference或returnAddress类型数据。</li>
<li>如果一个局部变量定义了但是没有赋初始值是不能使用的</li>
</ul>

        <h4 id="1-2-操作数栈"   >
          <a href="#1-2-操作数栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h4>
      <ul>
<li>Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈</li>
</ul>

        <h4 id="1-3-动态连接"   >
          <a href="#1-3-动态连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h4>
      <p>指向运行时常量池中该栈帧所属方法的引用。<br><strong>静态解析</strong>：符号引用在类加载阶段或第一次使用时转化为直接引用。<br><strong>动态连接</strong>：符号引用在每一次运行期间转化为直接引用。</p>

        <h4 id="1-4-方法返回地址"   >
          <a href="#1-4-方法返回地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h4>
      <p>方法正常退出时，调用者的<strong>PC计数器</strong>的值可以作为返回地址，栈帧中很可能会保存这个计数器的值。<br>方法异常退出时，返回地址通过<strong>异常处理器</strong>表来确定，栈帧中一般不会保存这部分信息。<br><strong>方法退出过程：</strong></p>
<ol>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值压入调用者栈帧的操作数栈</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令</li>
</ol>

        <h3 id="2-方法调用"   >
          <a href="#2-方法调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3>
      
        <h4 id="2-1-解析"   >
          <a href="#2-1-解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h4>
      <ul>
<li>只要能被 invokestatic 和 invokespecial 指令调用的方法都可以在解析阶段确定唯一的调用版本。</li>
<li>符合上述条件的的有<strong>静态方法、私有方法、实例构造器、父类方法</strong> 4 种。都称为<strong>非虚方法</strong>。其余方法为<strong>虚方法</strong>。<blockquote>
<p>final 方法也是非虚方法。</p>
</blockquote>
</li>
</ul>

        <h4 id="2-2-分派（与多态特性有关）"   >
          <a href="#2-2-分派（与多态特性有关）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-分派（与多态特性有关）" class="headerlink" title="2.2 分派（与多态特性有关）"></a>2.2 分派（与多态特性有关）</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th>静态分派</th>
<th>动态分派</th>
</tr>
</thead>
<tbody><tr>
<td>编译阶段</td>
<td>运行阶段</td>
</tr>
<tr>
<td>重载</td>
<td>重写</td>
</tr>
<tr>
<td>多分派（关心静态类型与方法参数两个因素）</td>
<td>单分派（只关心方法接收者）</td>
</tr>
</tbody></table></div>

        <h5 id="（1）静态分派（重载）"   >
          <a href="#（1）静态分派（重载）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）静态分派（重载）" class="headerlink" title="（1）静态分派（重载）"></a>（1）静态分派（重载）</h5>
      <p>所有通过静态类型来定位方法执行版本的分派动作称为静态分派。</p>
<blockquote>
<ul>
<li>方法重载是静态分派的典型应用  </li>
<li>静态分派发生在编译阶段</li>
</ul>
</blockquote>
<p><code>Human man = new Man();</code><br><code>Human</code>为变量的<strong>静态类型</strong>，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；<br><code>Man</code>为变量的<strong>实际类型</strong>，实际类型的变化结果在运行期才可以确定，编译期间不知道对象的实际类型。<br><strong>重载</strong>通过参数的<strong>静态类型而不是实际类型</strong>作为判定依据。</p>

        <h5 id="（2）动态分派（重写）"   >
          <a href="#（2）动态分派（重写）" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）动态分派（重写）" class="headerlink" title="（2）动态分派（重写）"></a>（2）动态分派（重写）</h5>
      <p>运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<blockquote>
<p>根据操作数栈中的信息确定接受者的实际类型</p>
</blockquote>

        <h5 id="（3）单分派与多分派"   >
          <a href="#（3）单分派与多分派" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）单分派与多分派" class="headerlink" title="（3）单分派与多分派"></a>（3）单分派与多分派</h5>
      <p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong>。<br><strong>单分派</strong>是根据一个宗量对目标方法进行选择，<strong>多分派</strong>则是根据多个宗量对目标方法进行选择。<br><strong>静态分派</strong>属于<strong>多分派</strong>，<strong>动态分派</strong>属于<strong>单分派</strong>。</p>

        <h5 id="（4）多分派的实现"   >
          <a href="#（4）多分派的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#（4）多分派的实现" class="headerlink" title="（4）多分派的实现"></a>（4）多分派的实现</h5>
      <p>为类在方法区中建立<strong>虚方法表</strong>，存放各个方法的实际入口地址。<br>如果子类重写了父类函数，虚方法表中存放指向子类实现版本的入口地址；否则，与父类相同方法的入口地址一致。</p>

        <h2 id="第十二章-Java内存模型与线程"   >
          <a href="#第十二章-Java内存模型与线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h2>
      
        <h3 id="1-Java内存模型"   >
          <a href="#1-Java内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">工作内存</th>
<th align="center">主内存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程对变量读取、赋值等操作</td>
<td align="center">线程间变量值的传递</td>
</tr>
<tr>
<td align="center">虚拟机栈中的部分区域</td>
<td align="center">Java堆中的对象实例数据部分</td>
</tr>
</tbody></table></div>

        <h4 id="1-1-内存间的交互操作"   >
          <a href="#1-1-内存间的交互操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-内存间的交互操作" class="headerlink" title="1.1 内存间的交互操作"></a>1.1 内存间的交互操作</h4>
      <p><img src="https://img-blog.csdn.net/20180522220730109" alt="image"></p>
<ol>
<li>**lock(锁定)**：作用于主内存的变量，把一个变量标记为一条线程独占状态</li>
<li>**unlock(解锁)**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>**read(读取)**：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>**load(载入)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>**use(使用)**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li>
<li>**assign(赋值)**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>**store(存储)**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li>
<li>**write(写入)**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li>
</ol>

        <h5 id="同步规则分析："   >
          <a href="#同步规则分析：" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步规则分析：" class="headerlink" title="同步规则分析："></a>同步规则分析：</h5>
      <ol>
<li>不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li>
</ol>

        <h4 id="2-3-volatile"   >
          <a href="#2-3-volatile" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-volatile" class="headerlink" title="2.3 volatile"></a>2.3 volatile</h4>
      
        <h5 id="1-保证可见性，read与load、aggsin与store两两不分开。"   >
          <a href="#1-保证可见性，read与load、aggsin与store两两不分开。" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-保证可见性，read与load、aggsin与store两两不分开。" class="headerlink" title="1. 保证可见性，read与load、aggsin与store两两不分开。"></a>1. 保证可见性，read与load、aggsin与store两两不分开。</h5>
      
        <h5 id="2-禁止指令重排序优化，内存屏障"   >
          <a href="#2-禁止指令重排序优化，内存屏障" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-禁止指令重排序优化，内存屏障" class="headerlink" title="2. 禁止指令重排序优化，内存屏障"></a>2. 禁止指令重排序优化，内存屏障</h5>
      
        <h4 id="2-4-long与double型变量的特殊规则"   >
          <a href="#2-4-long与double型变量的特殊规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4-long与double型变量的特殊规则" class="headerlink" title="2.4 long与double型变量的特殊规则"></a>2.4 long与double型变量的特殊规则</h4>
      <p>虚拟机不保证64位数据类型的load、store、read和write这四个操作的原子性。</p>
<blockquote>
<p>目前的商用虚拟机保证了64位数据的类型读写操作的原子性</p>
</blockquote>

        <h4 id="2-5-原子性、可见性与有序性"   >
          <a href="#2-5-原子性、可见性与有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h4>
      
        <h5 id="（1）原子性"   >
          <a href="#（1）原子性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h5>
      <ul>
<li>基本数据类型具备原子性</li>
<li><code>sychronized</code> 关键字保证更大范围内的原子性</li>
</ul>

        <h5 id="（2）可见性"   >
          <a href="#（2）可见性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）可见性" class="headerlink" title="（2）可见性"></a>（2）可见性</h5>
      <ul>
<li><code>volatile</code>、<code>sychronized</code>和<code>final</code>三个关键字实现可见性。</li>
<li><code>final</code>关键字的可见性：<br>被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把<code>this</code>的引用传递出去，那在其他线程中就能看到 final 字段的值。</li>
</ul>

        <h5 id="（3）有序性"   >
          <a href="#（3）有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h5>
      <ul>
<li><code>volatile</code>和<code>sychronized</code>两个关键字实现有序性。</li>
<li>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</li>
</ul>

        <h4 id="2-6-先行发生原则（happens-before）"   >
          <a href="#2-6-先行发生原则（happens-before）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-先行发生原则（happens-before）" class="headerlink" title="2.6 先行发生原则（happens-before）"></a>2.6 先行发生原则（happens-before）</h4>
      
        <h5 id="（1）定义"   >
          <a href="#（1）定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5>
      <ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li>
</ol>

        <h5 id="（2）具体规则"   >
          <a href="#（2）具体规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）具体规则" class="headerlink" title="（2）具体规则"></a>（2）具体规则</h5>
      <ol>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li><strong>程序中断规则</strong>：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li><strong>对象finalize规则</strong>：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ol>

        <h3 id="Java与线程"   >
          <a href="#Java与线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3>
      <blockquote>
<p>在Java中，JDK1.2之前由用户线程实现，JDK1.2之后使用基于操作系统原生线程模型实现，win和linux都是用的一对一的线程模型（一条Java线程映射到一条轻量级进程中）。</p>
</blockquote>

        <h4 id="1-线程的实现"   >
          <a href="#1-线程的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-线程的实现" class="headerlink" title="1. 线程的实现"></a>1. 线程的实现</h4>
      
        <h5 id="1-1-使用内核线程实现"   >
          <a href="#1-1-使用内核线程实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-使用内核线程实现" class="headerlink" title="1.1 使用内核线程实现"></a>1.1 使用内核线程实现</h5>
      <ul>
<li>不直接使用内核线程，而是使用内核线程的高级接口：轻量级进程。</li>
<li>轻量级进程与内核线程的数量比为 1 ：1。</li>
<li>轻量级进程消耗内核资源，一个系统支持的轻量级进程的数量是有限的。</li>
</ul>

        <h5 id="1-2-使用用户线程实现（实现复杂，没有使用）"   >
          <a href="#1-2-使用用户线程实现（实现复杂，没有使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-使用用户线程实现（实现复杂，没有使用）" class="headerlink" title="1.2 使用用户线程实现（实现复杂，没有使用）"></a>1.2 使用用户线程实现（实现复杂，没有使用）</h5>
      <ul>
<li>进程与用户线程之间是 1 ：N 的关系</li>
</ul>

        <h5 id="1-3-使用用户线程加轻量级进程混合实现"   >
          <a href="#1-3-使用用户线程加轻量级进程混合实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-使用用户线程加轻量级进程混合实现" class="headerlink" title="1.3 使用用户线程加轻量级进程混合实现"></a>1.3 使用用户线程加轻量级进程混合实现</h5>
      <ul>
<li>用户线程与轻量级进程之间是 N:M 的关系。</li>
</ul>

        <h4 id="2-线程调度"   >
          <a href="#2-线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h4>
      <ul>
<li>协同式线程调度：实现简单，但线程执行时间不可控</li>
<li>抢占式线程调度：Java一共10个优先级，但windows系统只有7个</li>
</ul>

        <h4 id="3-状态转换"   >
          <a href="#3-状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-状态转换" class="headerlink" title="3. 状态转换"></a>3. 状态转换</h4>
      <p><img src="https://pic2.zhimg.com/80/v2-326a2be9b86b1446d75b6f52f54c98fb_hd.jpg" alt="线程状态转移图"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
